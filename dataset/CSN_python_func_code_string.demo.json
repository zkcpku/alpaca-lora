{"func_code_string": "def __msgc_step3_discontinuity_localization(self):\n        \"\"\"\n        Estimate discontinuity in basis of low resolution image segmentation.\n        :return: discontinuity in low resolution\n        \"\"\"\n        import scipy\n\n        start = self._start_time\n        seg = 1 - self.segmentation.astype(np.int8)\n        self.stats[\"low level object voxels\"] = np.sum(seg)\n        self.stats[\"low level image voxels\"] = np.prod(seg.shape)\n        # in seg is now stored low resolution segmentation\n        # back to normal parameters\n        # step 2: discontinuity localization\n        # self.segparams = sparams_hi\n        seg_border = scipy.ndimage.filters.laplace(seg, mode=\"constant\")\n        logger.debug(\"seg_border: %s\", scipy.stats.describe(seg_border, axis=None))\n        # logger.debug(str(np.max(seg_border)))\n        # logger.debug(str(np.min(seg_border)))\n        seg_border[seg_border != 0] = 1\n        logger.debug(\"seg_border: %s\", scipy.stats.describe(seg_border, axis=None))\n        # scipy.ndimage.morphology.distance_transform_edt\n        boundary_dilatation_distance = self.segparams[\"boundary_dilatation_distance\"]\n        seg = scipy.ndimage.morphology.binary_dilation(\n            seg_border,\n            # seg,\n            np.ones(\n                [\n                    (boundary_dilatation_distance * 2) + 1,\n                    (boundary_dilatation_distance * 2) + 1,\n                    (boundary_dilatation_distance * 2) + 1,\n                ]\n            ),\n        )\n        if self.keep_temp_properties:\n            self.temp_msgc_lowres_discontinuity = seg\n        else:\n            self.temp_msgc_lowres_discontinuity = None\n\n        if self.debug_images:\n            import sed3\n\n            pd = sed3.sed3(seg_border)  # ), contour=seg)\n            pd.show()\n            pd = sed3.sed3(seg)  # ), contour=seg)\n            pd.show()\n        # segzoom = scipy.ndimage.interpolation.zoom(seg.astype('float'), zoom,\n        #                                                order=0).astype('int8')\n        self.stats[\"t3\"] = time.time() - start\n        return seg"}
{"func_code_string": "def __multiscale_gc_lo2hi_run(self):  # , pyed):\n        \"\"\"\n        Run Graph-Cut segmentation with refinement of low resolution multiscale graph.\n        In first step is performed normal GC on low resolution data\n        Second step construct finer grid on edges of segmentation from first\n        step.\n        There is no option for use without `use_boundary_penalties`\n        \"\"\"\n        # from PyQt4.QtCore import pyqtRemoveInputHook\n        # pyqtRemoveInputHook()\n        self._msgc_lo2hi_resize_init()\n        self.__msgc_step0_init()\n\n        hard_constraints = self.__msgc_step12_low_resolution_segmentation()\n        # ===== high resolution data processing\n        seg = self.__msgc_step3_discontinuity_localization()\n\n        self.stats[\"t3.1\"] = (time.time() - self._start_time)\n        graph = Graph(\n            seg,\n            voxelsize=self.voxelsize,\n            nsplit=self.segparams[\"block_size\"],\n            edge_weight_table=self._msgc_npenalty_table,\n            compute_low_nodes_index=True,\n        )\n\n        # graph.run() = graph.generate_base_grid() + graph.split_voxels()\n        # graph.run()\n        graph.generate_base_grid()\n        self.stats[\"t3.2\"] = (time.time() - self._start_time)\n        graph.split_voxels()\n\n        self.stats[\"t3.3\"] = (time.time() - self._start_time)\n\n        self.stats.update(graph.stats)\n        self.stats[\"t4\"] = (time.time() - self._start_time)\n        mul_mask, mul_val = self.__msgc_tlinks_area_weight_from_low_segmentation(seg)\n        area_weight = 1\n        unariesalt = self.__create_tlinks(\n            self.img,\n            self.voxelsize,\n            self.seeds,\n            area_weight=area_weight,\n            hard_constraints=hard_constraints,\n            mul_mask=None,\n            mul_val=None,\n        )\n        # N-links prepared\n        self.stats[\"t5\"] = (time.time() - self._start_time)\n        un, ind = np.unique(graph.msinds, return_index=True)\n        self.stats[\"t6\"] = (time.time() - self._start_time)\n\n        self.stats[\"t7\"] = (time.time() - self._start_time)\n        unariesalt2_lo2hi = np.hstack(\n            [unariesalt[ind, 0, 0].reshape(-1, 1), unariesalt[ind, 0, 1].reshape(-1, 1)]\n        )\n        nlinks_lo2hi = np.hstack([graph.edges, graph.edges_weights.reshape(-1, 1)])\n        if self.debug_images:\n            import sed3\n\n            ed = sed3.sed3(unariesalt[:, :, 0].reshape(self.img.shape))\n            ed.show()\n            import sed3\n\n            ed = sed3.sed3(unariesalt[:, :, 1].reshape(self.img.shape))\n            ed.show()\n            # ed = sed3.sed3(seg)\n            # ed.show()\n            # import sed3\n            # ed = sed3.sed3(graph.data)\n            # ed.show()\n            # import sed3\n            # ed = sed3.sed3(graph.msinds)\n            # ed.show()\n\n        # nlinks, unariesalt2, msinds = self.__msgc_step45678_construct_graph(area_weight, hard_constraints, seg)\n        # self.__msgc_step9_finish_perform_gc_and_reshape(nlinks, unariesalt2, msinds)\n        self.__msgc_step9_finish_perform_gc_and_reshape(\n            nlinks_lo2hi, unariesalt2_lo2hi, graph.msinds\n        )\n        self._msgc_lo2hi_resize_clean_finish()"}
{"func_code_string": "def __multiscale_gc_hi2lo_run(self):  # , pyed):\n        \"\"\"\n        Run Graph-Cut segmentation with simplifiyng of high resolution multiscale graph.\n        In first step is performed normal GC on low resolution data\n        Second step construct finer grid on edges of segmentation from first\n        step.\n        There is no option for use without `use_boundary_penalties`\n        \"\"\"\n        # from PyQt4.QtCore import pyqtRemoveInputHook\n        # pyqtRemoveInputHook()\n\n        self.__msgc_step0_init()\n        hard_constraints = self.__msgc_step12_low_resolution_segmentation()\n        # ===== high resolution data processing\n        seg = self.__msgc_step3_discontinuity_localization()\n        nlinks, unariesalt2, msinds = self.__msgc_step45678_hi2lo_construct_graph(\n            hard_constraints, seg\n        )\n        self.__msgc_step9_finish_perform_gc_and_reshape(nlinks, unariesalt2, msinds)"}
{"func_code_string": "def __ordered_values_by_indexes(self, data, inds):\n        \"\"\"\n        Return values (intensities) by indexes.\n\n        Used for multiscale graph cut.\n        data = [[0 1 1],\n                [0 2 2],\n                [0 2 2]]\n\n        inds = [[0 1 2],\n                [3 4 4],\n                [5 4 4]]\n\n        return: [0, 1, 1, 0, 2, 0]\n\n        If the data are not consistent, it will take the maximal value\n\n        \"\"\"\n        # get unique labels and their first indexes\n        # lab, linds = np.unique(inds, return_index=True)\n        # compute values by indexes\n        # values = data.reshape(-1)[linds]\n\n        # alternative slow implementation\n        # if there are different data on same index, it will take\n        # maximal value\n        # lab = np.unique(inds)\n        # values = [0]*len(lab)\n        # for label in lab:\n        #     values[label] = np.max(data[inds == label])\n        #\n        # values = np.asarray(values)\n\n        # yet another implementation\n        values = [None] * (np.max(inds) + 1)\n\n        linear_inds = inds.ravel()\n        linear_data = data.ravel()\n        for i in range(0, len(linear_inds)):\n            # going over all data pixels\n\n            if values[linear_inds[i]] is None:\n                # this index is found for first\n                values[linear_inds[i]] = linear_data[i]\n            elif values[linear_inds[i]] < linear_data[i]:\n                # here can be changed maximal or minimal value\n                values[linear_inds[i]] = linear_data[i]\n\n        values = np.asarray(values)\n\n        return values"}
{"func_code_string": "def __hi2lo_multiscale_indexes(self, mask, orig_shape):  # , zoom):\n        \"\"\"\n        Function computes multiscale indexes of ndarray.\n\n        mask: Says where is original resolution (0) and where is small\n        resolution (1). Mask is in small resolution.\n\n        orig_shape: Original shape of input data.\n        zoom: Usually number greater then 1\n\n        result = [[0 1 2],\n                  [3 4 4],\n                  [5 4 4]]\n        \"\"\"\n\n        mask_orig = zoom_to_shape(mask, orig_shape, dtype=np.int8)\n\n        inds_small = np.arange(mask.size).reshape(mask.shape)\n        inds_small_in_orig = zoom_to_shape(inds_small, orig_shape, dtype=np.int8)\n        inds_orig = np.arange(np.prod(orig_shape)).reshape(orig_shape)\n\n        # inds_orig = inds_orig * mask_orig\n        inds_orig += np.max(inds_small_in_orig) + 1\n        # print 'indexes'\n        # import py3DSeedEditor as ped\n        # import pdb; pdb.set_trace() # BREAKPOINT\n\n        #  '==' is not the same as 'is' for numpy.array\n        inds_small_in_orig[mask_orig == True] = inds_orig[mask_orig == True]  # noqa\n        inds = inds_small_in_orig\n        # print np.max(inds)\n        # print np.min(inds)\n        inds = relabel_squeeze(inds)\n        logger.debug(\n            \"Index after relabeling: %s\", scipy.stats.describe(inds, axis=None)\n        )\n        # logger.debug(\"Minimal index after relabeling: \" + str(np.min(inds)))\n        # inds_orig[mask_orig==True] = 0\n        # inds_small_in_orig[mask_orig==False] = 0\n        # inds = (inds_orig + np.max(inds_small_in_orig) + 1) + inds_small_in_orig\n\n        return inds, mask_orig"}
{"func_code_string": "def interactivity(self, min_val=None, max_val=None, qt_app=None):\n        \"\"\"\n        Interactive seed setting with 3d seed editor\n        \"\"\"\n        from .seed_editor_qt import QTSeedEditor\n        from PyQt4.QtGui import QApplication\n\n        if min_val is None:\n            min_val = np.min(self.img)\n\n        if max_val is None:\n            max_val = np.max(self.img)\n\n        window_c = (max_val + min_val) / 2  # .astype(np.int16)\n        window_w = max_val - min_val  # .astype(np.int16)\n\n        if qt_app is None:\n            qt_app = QApplication(sys.argv)\n\n        pyed = QTSeedEditor(\n            self.img,\n            modeFun=self.interactivity_loop,\n            voxelSize=self.voxelsize,\n            seeds=self.seeds,\n            volume_unit=self.volume_unit,\n        )\n\n        pyed.changeC(window_c)\n        pyed.changeW(window_w)\n\n        qt_app.exec_()"}
{"func_code_string": "def set_seeds(self, seeds):\n        \"\"\"\n        Function for manual seed setting. Sets variable seeds and prepares\n        voxels for density model.\n        :param seeds: ndarray (0 - nothing, 1 - object, 2 - background,\n        3 - object just hard constraints, no model training, 4 - background \n        just hard constraints, no model training)\n        \"\"\"\n        if self.img.shape != seeds.shape:\n            raise Exception(\"Seeds must be same size as input image\")\n\n        self.seeds = seeds.astype(\"int8\")\n        self.voxels1 = self.img[self.seeds == 1]\n        self.voxels2 = self.img[self.seeds == 2]"}
{"func_code_string": "def run(self, run_fit_model=True):\n        \"\"\"\n        Run the Graph Cut segmentation according to preset parameters.\n\n        :param run_fit_model: Allow to skip model fit when the model is prepared before\n        :return:\n        \"\"\"\n\n        if run_fit_model:\n            self.fit_model(self.img, self.voxelsize, self.seeds)\n\n        self._start_time = time.time()\n        if self.segparams[\"method\"].lower() in (\"graphcut\", \"gc\"):\n            self.__single_scale_gc_run()\n        elif self.segparams[\"method\"].lower() in (\n            \"multiscale_graphcut\",\n            \"multiscale_gc\",\n            \"msgc\",\n            \"msgc_lo2hi\",\n            \"lo2hi\",\n            \"multiscale_graphcut_lo2hi\",\n        ):\n            logger.debug(\"performing multiscale Graph-Cut lo2hi\")\n            self.__multiscale_gc_lo2hi_run()\n        elif self.segparams[\"method\"].lower() in (\n            \"msgc_hi2lo\",\n            \"hi2lo\",\n            \"multiscale_graphcut_hi2lo\",\n        ):\n            logger.debug(\"performing multiscale Graph-Cut hi2lo\")\n            self.__multiscale_gc_hi2lo_run()\n        else:\n            logger.error(\"Unknown segmentation method: \" + self.segparams[\"method\"])"}
{"func_code_string": "def __set_hard_hard_constraints(self, tdata1, tdata2, seeds):\n        \"\"\"\n        it works with seed labels:\n        0: nothing\n        1: object 1 - full seeds\n        2: object 2 - full seeds\n        3: object 1 - not a training seeds\n        4: object 2 - not a training seeds\n        \"\"\"\n        seeds_mask = (seeds == 1) | (seeds == 3)\n        tdata2[seeds_mask] = np.max(tdata2) + 1\n        tdata1[seeds_mask] = 0\n\n        seeds_mask = (seeds == 2) | (seeds == 4)\n        tdata1[seeds_mask] = np.max(tdata1) + 1\n        tdata2[seeds_mask] = 0\n\n        return tdata1, tdata2"}
{"func_code_string": "def __similarity_for_tlinks_obj_bgr(\n        self,\n        data,\n        voxelsize,\n        # voxels1, voxels2,\n        # seeds, otherfeatures=None\n    ):\n        \"\"\"\n        Compute edge values for graph cut tlinks based on image intensity\n        and texture.\n        \"\"\"\n        # self.fit_model(data, voxelsize, seeds)\n        # There is a need to have small vaues for good fit\n        # R(obj) = -ln( Pr (Ip | O) )\n        # R(bck) = -ln( Pr (Ip | B) )\n        # Boykov2001b\n        # ln is computed in likelihood\n        tdata1 = (-(self.mdl.likelihood_from_image(data, voxelsize, 1))) * 10\n        tdata2 = (-(self.mdl.likelihood_from_image(data, voxelsize, 2))) * 10\n\n        # to spare some memory\n        dtype = np.int16\n        if np.any(tdata1 > 32760):\n            dtype = np.float32\n        if np.any(tdata2 > 32760):\n            dtype = np.float32\n\n        if self.segparams[\"use_apriori_if_available\"] and self.apriori is not None:\n            logger.debug(\"using apriori information\")\n            gamma = self.segparams[\"apriori_gamma\"]\n            a1 = (-np.log(self.apriori * 0.998 + 0.001)) * 10\n            a2 = (-np.log(0.999 - (self.apriori * 0.998))) * 10\n            # logger.debug('max ' + str(np.max(tdata1)) + ' min ' + str(np.min(tdata1)))\n            # logger.debug('max ' + str(np.max(tdata2)) + ' min ' + str(np.min(tdata2)))\n            # logger.debug('max ' + str(np.max(a1)) + ' min ' + str(np.min(a1)))\n            # logger.debug('max ' + str(np.max(a2)) + ' min ' + str(np.min(a2)))\n            tdata1u = (((1 - gamma) * tdata1) + (gamma * a1)).astype(dtype)\n            tdata2u = (((1 - gamma) * tdata2) + (gamma * a2)).astype(dtype)\n            tdata1 = tdata1u\n            tdata2 = tdata2u\n            # logger.debug('   max ' + str(np.max(tdata1)) + ' min ' + str(np.min(tdata1)))\n            # logger.debug('   max ' + str(np.max(tdata2)) + ' min ' + str(np.min(tdata2)))\n            # logger.debug('gamma ' + str(gamma))\n\n            # import sed3\n            # ed = sed3.show_slices(tdata1)\n            # ed = sed3.show_slices(tdata2)\n            del tdata1u\n            del tdata2u\n            del a1\n            del a2\n\n        # if np.any(tdata1 < 0) or np.any(tdata2 <0):\n        #     logger.error(\"Problem with tlinks. Likelihood is < 0\")\n\n        # if self.debug_images:\n        #     self.__show_debug_tdata_images(tdata1, tdata2, suptitle=\"likelihood\")\n        return tdata1, tdata2"}
{"func_code_string": "def __create_nlinks(self, data, inds=None, boundary_penalties_fcn=None):\n        \"\"\"\n        Compute nlinks grid from data shape information. For boundary penalties\n        are data (intensities) values are used.\n\n        ins: Default is None. Used for multiscale GC. This are indexes of\n        multiscale pixels. Next example shows one superpixel witn index 2.\n        inds = [\n            [1 2 2],\n            [3 2 2],\n            [4 5 6]]\n\n        boundary_penalties_fcn: is function with one argument - axis. It can\n            it can be used for setting penalty weights between neighbooring\n            pixels.\n\n        \"\"\"\n        # use the gerneral graph algorithm\n        # first, we construct the grid graph\n        start = time.time()\n        if inds is None:\n            inds = np.arange(data.size).reshape(data.shape)\n        # if not self.segparams['use_boundary_penalties'] and \\\n        #         boundary_penalties_fcn is None :\n        if boundary_penalties_fcn is None:\n            # This is faster for some specific format\n            edgx = np.c_[inds[:, :, :-1].ravel(), inds[:, :, 1:].ravel()]\n            edgy = np.c_[inds[:, :-1, :].ravel(), inds[:, 1:, :].ravel()]\n            edgz = np.c_[inds[:-1, :, :].ravel(), inds[1:, :, :].ravel()]\n\n        else:\n            logger.info(\"use_boundary_penalties\")\n\n            bpw = self.segparams[\"boundary_penalties_weight\"]\n\n            bpa = boundary_penalties_fcn(2)\n            # id1=inds[:, :, :-1].ravel()\n            edgx = np.c_[\n                inds[:, :, :-1].ravel(),\n                inds[:, :, 1:].ravel(),\n                # cc * np.ones(id1.shape)\n                bpw * bpa[:, :, 1:].ravel(),\n            ]\n\n            bpa = boundary_penalties_fcn(1)\n            # id1 =inds[:, 1:, :].ravel()\n            edgy = np.c_[\n                inds[:, :-1, :].ravel(),\n                inds[:, 1:, :].ravel(),\n                # cc * np.ones(id1.shape)]\n                bpw * bpa[:, 1:, :].ravel(),\n            ]\n\n            bpa = boundary_penalties_fcn(0)\n            # id1 = inds[1:, :, :].ravel()\n            edgz = np.c_[\n                inds[:-1, :, :].ravel(),\n                inds[1:, :, :].ravel(),\n                # cc * np.ones(id1.shape)]\n                bpw * bpa[1:, :, :].ravel(),\n            ]\n\n        # import pdb; pdb.set_trace()\n        edges = np.vstack([edgx, edgy, edgz]).astype(np.int32)\n        # edges - seznam indexu hran, kteres spolu sousedi\\\n        elapsed = time.time() - start\n        self.stats[\"_create_nlinks time\"] = elapsed\n        logger.info(\"__create nlinks time \" + str(elapsed))\n        return edges"}
{"func_code_string": "def debug_get_reconstructed_similarity(\n        self,\n        data3d=None,\n        voxelsize=None,\n        seeds=None,\n        area_weight=1,\n        hard_constraints=True,\n        return_unariesalt=False,\n    ):\n        \"\"\"\n        Use actual model to calculate similarity. If no input is given the last image is used.\n        :param data3d:\n        :param voxelsize:\n        :param seeds:\n        :param area_weight:\n        :param hard_constraints:\n        :param return_unariesalt:\n        :return:\n        \"\"\"\n        if data3d is None:\n            data3d = self.img\n        if voxelsize is None:\n            voxelsize = self.voxelsize\n        if seeds is None:\n            seeds = self.seeds\n\n        unariesalt = self.__create_tlinks(\n            data3d,\n            voxelsize,\n            # voxels1, voxels2,\n            seeds,\n            area_weight,\n            hard_constraints,\n        )\n        if return_unariesalt:\n            return unariesalt\n        else:\n            return self._reshape_unariesalt_to_similarity(unariesalt, data3d.shape)"}
{"func_code_string": "def debug_show_reconstructed_similarity(\n        self,\n        data3d=None,\n        voxelsize=None,\n        seeds=None,\n        area_weight=1,\n        hard_constraints=True,\n        show=True,\n        bins=20,\n        slice_number=None,\n    ):\n        \"\"\"\n        Show tlinks.\n        :param data3d: ndarray with input data\n        :param voxelsize:\n        :param seeds:\n        :param area_weight:\n        :param hard_constraints:\n        :param show:\n        :param bins: histogram bins number\n        :param slice_number:\n        :return:\n        \"\"\"\n\n        unariesalt = self.debug_get_reconstructed_similarity(\n            data3d,\n            voxelsize=voxelsize,\n            seeds=seeds,\n            area_weight=area_weight,\n            hard_constraints=hard_constraints,\n            return_unariesalt=True,\n        )\n\n        self._debug_show_unariesalt(\n            unariesalt, show=show, bins=bins, slice_number=slice_number\n        )"}
{"func_code_string": "def debug_inspect_node(self, node_msindex):\n        \"\"\"\n        Get info about the node. See pycut.inspect_node() for details.\n        Processing is done in temporary shape.\n\n        :param node_seed:\n        :return: node_unariesalt, node_neighboor_edges_and_weights, node_neighboor_seeds\n        \"\"\"\n        return inspect_node(self.nlinks, self.unariesalt2, self.msinds, node_msindex)"}
{"func_code_string": "def debug_interactive_inspect_node(self):\n        \"\"\"\n        Call after segmentation to see selected node neighborhood.\n        User have to select one node by click.\n        :return:\n        \"\"\"\n        if (\n            np.sum(\n                np.abs(\n                    np.asarray(self.msinds.shape) - np.asarray(self.segmentation.shape)\n                )\n            )\n            == 0\n        ):\n            segmentation = self.segmentation\n        else:\n            segmentation = self.temp_msgc_resized_segmentation\n\n        logger.info(\"Click to select one voxel of interest\")\n        import sed3\n\n        ed = sed3.sed3(self.msinds, contour=segmentation == 0)\n        ed.show()\n        edseeds = ed.seeds\n        node_msindex = get_node_msindex(self.msinds, edseeds)\n\n        node_unariesalt, node_neighboor_edges_and_weights, node_neighboor_seeds = self.debug_inspect_node(\n            node_msindex\n        )\n        import sed3\n\n        ed = sed3.sed3(\n            self.msinds, contour=segmentation == 0, seeds=node_neighboor_seeds\n        )\n        ed.show()\n\n        return (\n            node_unariesalt,\n            node_neighboor_edges_and_weights,\n            node_neighboor_seeds,\n            node_msindex,\n        )"}
{"func_code_string": "def _ssgc_prepare_data_and_run_computation(\n        self,\n        # voxels1, voxels2,\n        hard_constraints=True,\n        area_weight=1,\n    ):\n        \"\"\"\n        Setting of data.\n        You need set seeds if you want use hard_constraints.\n        \"\"\"\n        # from PyQt4.QtCore import pyqtRemoveInputHook\n        # pyqtRemoveInputHook()\n        # import pdb; pdb.set_trace() # BREAKPOINT\n\n        unariesalt = self.__create_tlinks(\n            self.img,\n            self.voxelsize,\n            # voxels1, voxels2,\n            self.seeds,\n            area_weight,\n            hard_constraints,\n        )\n        #  n\u011bkter\u00e9m testu  organ semgmentation dosahuj\u00ed unaries -15. co\u017e je podin\u00e9\n        # sta\u010d\u00ed vyhodit print p\u0159ed if a je to vid\u011bt\n        logger.debug(\"unaries %.3g , %.3g\" % (np.max(unariesalt), np.min(unariesalt)))\n        # create potts pairwise\n        # pairwiseAlpha = -10\n        pairwise = -(np.eye(2) - 1)\n        pairwise = (self.segparams[\"pairwise_alpha\"] * pairwise).astype(np.int32)\n        # pairwise = np.array([[0,30],[30,0]]).astype(np.int32)\n        # print pairwise\n\n        self.iparams = {}\n\n        if self.segparams[\"use_boundary_penalties\"]:\n            sigma = self.segparams[\"boundary_penalties_sigma\"]\n            # set boundary penalties function\n            # Default are penalties based on intensity differences\n            boundary_penalties_fcn = lambda ax: self._boundary_penalties_array(\n                axis=ax, sigma=sigma\n            )\n        else:\n            boundary_penalties_fcn = None\n        nlinks = self.__create_nlinks(\n            self.img, boundary_penalties_fcn=boundary_penalties_fcn\n        )\n\n        self.stats[\"tlinks shape\"].append(unariesalt.reshape(-1, 2).shape)\n        self.stats[\"nlinks shape\"].append(nlinks.shape)\n        # we flatten the unaries\n        # result_graph = cut_from_graph(nlinks, unaries.reshape(-1, 2),\n        # pairwise)\n        start = time.time()\n        if self.debug_images:\n            self._debug_show_unariesalt(unariesalt)\n        result_graph = pygco.cut_from_graph(nlinks, unariesalt.reshape(-1, 2), pairwise)\n        elapsed = time.time() - start\n        self.stats[\"gc time\"] = elapsed\n        result_labeling = result_graph.reshape(self.img.shape)\n\n        return result_labeling"}
{"func_code_string": "def resize_to_shape(data, shape, zoom=None, mode=\"nearest\", order=0):\n    \"\"\"\n    Function resize input data to specific shape.\n    :param data: input 3d array-like data\n    :param shape: shape of output data\n    :param zoom: zoom is used for back compatibility\n    :mode: default is 'nearest'\n    \"\"\"\n    # @TODO remove old code in except part\n    # TODO use function from library in future\n\n    try:\n        # rint 'pred vyjimkou'\n        # aise Exception ('test without skimage')\n        # rint 'za vyjimkou'\n        import skimage\n        import skimage.transform\n\n        # Now we need reshape  seeds and segmentation to original size\n\n        # with warnings.catch_warnings():\n        #     warnings.filterwarnings(\"ignore\", \".*'constant', will be changed to.*\")\n        segm_orig_scale = skimage.transform.resize(\n            data, shape, order=0, preserve_range=True, mode=\"reflect\"\n        )\n\n        segmentation = segm_orig_scale\n        logger.debug(\"resize to orig with skimage\")\n    except:\n        if zoom is None:\n            zoom = shape / np.asarray(data.shape).astype(np.double)\n        segmentation = resize_to_shape_with_zoom(\n            data, zoom=zoom, mode=mode, order=order\n        )\n\n    return segmentation"}
{"func_code_string": "def seed_zoom(seeds, zoom):\n    \"\"\"\n    Smart zoom for sparse matrix. If there is resize to bigger resolution\n    thin line of label could be lost. This function prefers labels larger\n    then zero. If there is only one small voxel in larger volume with zeros\n    it is selected.\n    \"\"\"\n    # import scipy\n    # loseeds=seeds\n    labels = np.unique(seeds)\n    # remove first label - 0\n    labels = np.delete(labels, 0)\n    # @TODO smart interpolation for seeds in one block\n    #        loseeds = scipy.ndimage.interpolation.zoom(\n    #            seeds, zoom, order=0)\n    loshape = np.ceil(np.array(seeds.shape) * 1.0 / zoom).astype(np.int)\n    loseeds = np.zeros(loshape, dtype=np.int8)\n    loseeds = loseeds.astype(np.int8)\n    for label in labels:\n        a, b, c = np.where(seeds == label)\n        loa = np.round(a // zoom)\n        lob = np.round(b // zoom)\n        loc = np.round(c // zoom)\n        # loseeds = np.zeros(loshape)\n\n        loseeds[loa, lob, loc] += label\n        # this is to detect conflict seeds\n        loseeds[loseeds > label] = 100\n\n    # remove conflict seeds\n    loseeds[loseeds > 99] = 0\n\n    # import py3DSeedEditor\n    # ped = py3DSeedEditor.py3DSeedEditor(loseeds)\n    # ped.show()\n\n    return loseeds"}
{"func_code_string": "def zoom_to_shape(data, shape, dtype=None):\n    \"\"\"\n    Zoom data to specific shape.\n    \"\"\"\n    import scipy\n    import scipy.ndimage\n\n    zoomd = np.array(shape) / np.array(data.shape, dtype=np.double)\n    import warnings\n\n    datares = scipy.ndimage.interpolation.zoom(data, zoomd, order=0, mode=\"reflect\")\n\n    if datares.shape != shape:\n        logger.warning(\"Zoom with different output shape\")\n    dataout = np.zeros(shape, dtype=dtype)\n    shpmin = np.minimum(dataout.shape, shape)\n\n    dataout[: shpmin[0], : shpmin[1], : shpmin[2]] = datares[\n        : shpmin[0], : shpmin[1], : shpmin[2]\n    ]\n    return datares"}
{"func_code_string": "def crop(data, crinfo):\n    \"\"\"\n    Crop the data.\n\n    crop(data, crinfo)\n\n    :param crinfo: min and max for each axis - [[minX, maxX], [minY, maxY], [minZ, maxZ]]\n\n    \"\"\"\n    crinfo = fix_crinfo(crinfo)\n    return data[\n        __int_or_none(crinfo[0][0]) : __int_or_none(crinfo[0][1]),\n        __int_or_none(crinfo[1][0]) : __int_or_none(crinfo[1][1]),\n        __int_or_none(crinfo[2][0]) : __int_or_none(crinfo[2][1]),\n    ]"}
{"func_code_string": "def combinecrinfo(crinfo1, crinfo2):\n    \"\"\"\n    Combine two crinfos. First used is crinfo1, second used is crinfo2.\n    \"\"\"\n    crinfo1 = fix_crinfo(crinfo1)\n    crinfo2 = fix_crinfo(crinfo2)\n\n    crinfo = [\n        [crinfo1[0][0] + crinfo2[0][0], crinfo1[0][0] + crinfo2[0][1]],\n        [crinfo1[1][0] + crinfo2[1][0], crinfo1[1][0] + crinfo2[1][1]],\n        [crinfo1[2][0] + crinfo2[2][0], crinfo1[2][0] + crinfo2[2][1]],\n    ]\n\n    return crinfo"}
{"func_code_string": "def crinfo_from_specific_data(data, margin=0):\n    \"\"\"\n    Create crinfo of minimum orthogonal nonzero block in input data.\n\n    :param data: input data\n    :param margin: add margin to minimum block\n    :return:\n    \"\"\"\n    # hled\u00e1me automatick\u00fd o\u0159ez, nonzero d\u00e1 indexy\n    logger.debug(\"crinfo\")\n    logger.debug(str(margin))\n    nzi = np.nonzero(data)\n    logger.debug(str(nzi))\n\n    if np.isscalar(margin):\n        margin = [margin] * 3\n\n    x1 = np.min(nzi[0]) - margin[0]\n    x2 = np.max(nzi[0]) + margin[0] + 1\n    y1 = np.min(nzi[1]) - margin[0]\n    y2 = np.max(nzi[1]) + margin[0] + 1\n    z1 = np.min(nzi[2]) - margin[0]\n    z2 = np.max(nzi[2]) + margin[0] + 1\n\n    # o\u0161et\u0159en\u00ed mez\u00ed pol\u00ed\n    if x1 < 0:\n        x1 = 0\n    if y1 < 0:\n        y1 = 0\n    if z1 < 0:\n        z1 = 0\n\n    if x2 > data.shape[0]:\n        x2 = data.shape[0] - 1\n    if y2 > data.shape[1]:\n        y2 = data.shape[1] - 1\n    if z2 > data.shape[2]:\n        z2 = data.shape[2] - 1\n\n    # o\u0159ez\n    crinfo = [[x1, x2], [y1, y2], [z1, z2]]\n    return crinfo"}
{"func_code_string": "def uncrop(data, crinfo, orig_shape, resize=False, outside_mode=\"constant\", cval=0):\n    \"\"\"\n    Put some boundary to input image.\n\n\n    :param data: input data\n    :param crinfo: array with minimum and maximum index along each axis\n        [[minX, maxX],[minY, maxY],[minZ, maxZ]]. If crinfo is None, the whole input image is placed into [0, 0, 0].\n        If crinfo is just series of three numbers, it is used as an initial point for input image placement.\n    :param orig_shape: shape of uncropped image\n    :param resize: True or False (default). Usefull if the data.shape does not fit to crinfo shape.\n    :param outside_mode: 'constant', 'nearest'\n    :return:\n    \"\"\"\n\n    if crinfo is None:\n        crinfo = list(zip([0] * data.ndim, orig_shape))\n    elif np.asarray(crinfo).size == data.ndim:\n        crinfo = list(zip(crinfo, np.asarray(crinfo) + data.shape))\n\n    crinfo = fix_crinfo(crinfo)\n    data_out = np.ones(orig_shape, dtype=data.dtype) * cval\n\n    # print 'uncrop ', crinfo\n    # print orig_shape\n    # print data.shape\n    if resize:\n        data = resize_to_shape(data, crinfo[:, 1] - crinfo[:, 0])\n\n    startx = np.round(crinfo[0][0]).astype(int)\n    starty = np.round(crinfo[1][0]).astype(int)\n    startz = np.round(crinfo[2][0]).astype(int)\n\n    data_out[\n        # np.round(crinfo[0][0]).astype(int):np.round(crinfo[0][1]).astype(int)+1,\n        # np.round(crinfo[1][0]).astype(int):np.round(crinfo[1][1]).astype(int)+1,\n        # np.round(crinfo[2][0]).astype(int):np.round(crinfo[2][1]).astype(int)+1\n        startx : startx + data.shape[0],\n        starty : starty + data.shape[1],\n        startz : startz + data.shape[2],\n    ] = data\n\n    if outside_mode == \"nearest\":\n        # for ax in range(data.ndims):\n        # ax = 0\n\n        # copy border slice to pixels out of boundary - the higher part\n        for ax in range(data.ndim):\n            # the part under the crop\n            start = np.round(crinfo[ax][0]).astype(int)\n            slices = [slice(None), slice(None), slice(None)]\n            slices[ax] = start\n            repeated_slice = np.expand_dims(data_out[slices], ax)\n            append_sz = start\n            if append_sz > 0:\n                tile0 = np.repeat(repeated_slice, append_sz, axis=ax)\n                slices = [slice(None), slice(None), slice(None)]\n                slices[ax] = slice(None, start)\n                # data_out[start + data.shape[ax] : , :, :] = tile0\n                data_out[slices] = tile0\n                # plt.imshow(np.squeeze(repeated_slice))\n                # plt.show()\n\n            # the part over the crop\n            start = np.round(crinfo[ax][0]).astype(int)\n            slices = [slice(None), slice(None), slice(None)]\n            slices[ax] = start + data.shape[ax] - 1\n            repeated_slice = np.expand_dims(data_out[slices], ax)\n            append_sz = data_out.shape[ax] - (start + data.shape[ax])\n            if append_sz > 0:\n                tile0 = np.repeat(repeated_slice, append_sz, axis=ax)\n                slices = [slice(None), slice(None), slice(None)]\n                slices[ax] = slice(start + data.shape[ax], None)\n                # data_out[start + data.shape[ax] : , :, :] = tile0\n                data_out[slices] = tile0\n                # plt.imshow(np.squeeze(repeated_slice))\n                # plt.show()\n\n    return data_out"}
{"func_code_string": "def fix_crinfo(crinfo, to=\"axis\"):\n    \"\"\"\n    Function recognize order of crinfo and convert it to proper format.\n    \"\"\"\n\n    crinfo = np.asarray(crinfo)\n    if crinfo.shape[0] == 2:\n        crinfo = crinfo.T\n\n    return crinfo"}
{"func_code_string": "def grid_edges(shape, inds=None, return_directions=True):\n    \"\"\"\n    Get list of grid edges\n    :param shape:\n    :param inds:\n    :param return_directions:\n    :return:\n    \"\"\"\n    if inds is None:\n        inds = np.arange(np.prod(shape)).reshape(shape)\n    # if not self.segparams['use_boundary_penalties'] and \\\n    #         boundary_penalties_fcn is None :\n    if len(shape) == 2:\n        edgx = np.c_[inds[:, :-1].ravel(), inds[:, 1:].ravel()]\n        edgy = np.c_[inds[:-1, :].ravel(), inds[1:, :].ravel()]\n\n        edges = [edgx, edgy]\n\n        directions = [\n            np.ones([edgx.shape[0]], dtype=np.int8) * 0,\n            np.ones([edgy.shape[0]], dtype=np.int8) * 1,\n        ]\n\n    elif len(shape) == 3:\n        # This is faster for some specific format\n        edgx = np.c_[inds[:, :, :-1].ravel(), inds[:, :, 1:].ravel()]\n        edgy = np.c_[inds[:, :-1, :].ravel(), inds[:, 1:, :].ravel()]\n        edgz = np.c_[inds[:-1, :, :].ravel(), inds[1:, :, :].ravel()]\n        edges = [edgx, edgy, edgz]\n    else:\n        logger.error(\"Expected 2D or 3D data\")\n\n    # for all edges along first direction put 0, for second direction put 1, for third direction put 3\n    if return_directions:\n        directions = []\n        for idirection in range(len(shape)):\n            directions.append(\n                np.ones([edges[idirection].shape[0]], dtype=np.int8) * idirection\n            )\n    edges = np.concatenate(edges)\n    if return_directions:\n        edge_dir = np.concatenate(directions)\n        return edges, edge_dir\n    else:\n        return edges"}
{"func_code_string": "def gen_grid_2d(shape, voxelsize):\n    \"\"\"\n    Generate list of edges for a base grid.\n    \"\"\"\n    nr, nc = shape\n    nrm1, ncm1 = nr - 1, nc - 1\n    # sh = nm.asarray(shape)\n    # calculate number of edges, in 2D: (nrows * (ncols - 1)) + ((nrows - 1) * ncols)\n    nedges = 0\n    for direction in range(len(shape)):\n        sh = copy.copy(list(shape))\n        sh[direction] += -1\n        nedges += nm.prod(sh)\n\n    nedges_old = ncm1 * nr + nrm1 * nc\n    edges = nm.zeros((nedges, 2), dtype=nm.int16)\n    edge_dir = nm.zeros((ncm1 * nr + nrm1 * nc,), dtype=nm.bool)\n    nodes = nm.zeros((nm.prod(shape), 3), dtype=nm.float32)\n\n    # edges\n    idx = 0\n    row = nm.zeros((ncm1, 2), dtype=nm.int16)\n    row[:, 0] = nm.arange(ncm1)\n    row[:, 1] = nm.arange(ncm1) + 1\n    for ii in range(nr):\n        edges[slice(idx, idx + ncm1), :] = row + nc * ii\n        idx += ncm1\n\n    edge_dir[slice(0, idx)] = 0  # horizontal dir\n\n    idx0 = idx\n    col = nm.zeros((nrm1, 2), dtype=nm.int16)\n    col[:, 0] = nm.arange(nrm1) * nc\n    col[:, 1] = nm.arange(nrm1) * nc + nc\n    for ii in range(nc):\n        edges[slice(idx, idx + nrm1), :] = col + ii\n        idx += nrm1\n\n    edge_dir[slice(idx0, idx)] = 1  # vertical dir\n\n    # nodes\n    idx = 0\n    row = nm.zeros((nc, 3), dtype=nm.float32)\n    row[:, 0] = voxelsize[0] * (nm.arange(nc) + 0.5)\n    row[:, 1] = voxelsize[1] * 0.5\n    for ii in range(nr):\n        nodes[slice(idx, idx + nc), :] = row\n        row[:, 1] += voxelsize[1]\n        idx += nc\n\n    return nodes, edges, edge_dir"}
{"func_code_string": "def write_grid_to_vtk(fname, nodes, edges, node_flag=None, edge_flag=None):\n    \"\"\"\n    Write nodes and edges to VTK file\n    :param fname: VTK filename\n    :param nodes:\n    :param edges:\n    :param node_flag: set if this node is really used in output\n    :param edge_flag: set if this flag is used in output\n    :return:\n    \"\"\"\n\n    if node_flag is None:\n        node_flag = np.ones([nodes.shape[0]], dtype=np.bool)\n    if edge_flag is None:\n        edge_flag = np.ones([edges.shape[0]], dtype=np.bool)\n    nodes = make_nodes_3d(nodes)\n    f = open(fname, \"w\")\n\n    f.write(\"# vtk DataFile Version 2.6\\n\")\n    f.write(\"output file\\nASCII\\nDATASET UNSTRUCTURED_GRID\\n\")\n\n    idxs = nm.where(node_flag > 0)[0]\n    nnd = len(idxs)\n    aux = -nm.ones(node_flag.shape, dtype=nm.int32)\n    aux[idxs] = nm.arange(nnd, dtype=nm.int32)\n    f.write(\"\\nPOINTS %d float\\n\" % nnd)\n    for ndi in idxs:\n        f.write(\"%.6f %.6f %.6f\\n\" % tuple(nodes[ndi, :]))\n\n    idxs = nm.where(edge_flag > 0)[0]\n    ned = len(idxs)\n    f.write(\"\\nCELLS %d %d\\n\" % (ned, ned * 3))\n    for edi in idxs:\n        f.write(\"2 %d %d\\n\" % tuple(aux[edges[edi, :]]))\n\n    f.write(\"\\nCELL_TYPES %d\\n\" % ned)\n    for edi in idxs:\n        f.write(\"3\\n\")"}
{"func_code_string": "def add_nodes(self, coors, node_low_or_high=None):\n        \"\"\"\n        Add new nodes at the end of the list.\n        \"\"\"\n        last = self.lastnode\n        if type(coors) is nm.ndarray:\n            if len(coors.shape) == 1:\n                coors = coors.reshape((1, coors.size))\n\n            nadd = coors.shape[0]\n            idx = slice(last, last + nadd)\n        else:\n            nadd = 1\n            idx = self.lastnode\n        right_dimension = coors.shape[1]\n        self.nodes[idx, :right_dimension] = coors\n        self.node_flag[idx] = True\n        self.lastnode += nadd\n        self.nnodes += nadd"}
{"func_code_string": "def add_edges(self, conn, edge_direction, edge_group=None, edge_low_or_high=None):\n        \"\"\"\n        Add new edges at the end of the list.\n        :param edge_direction: direction flag\n        :param edge_group: describes group of edges from same low super node and same direction\n        :param edge_low_or_high: zero for low to low resolution, one for high to high or high to low resolution.\n        It is used to set weight from weight table.\n        \"\"\"\n        last = self.lastedge\n        if type(conn) is nm.ndarray:\n            nadd = conn.shape[0]\n            idx = slice(last, last + nadd)\n            if edge_group is None:\n                edge_group = nm.arange(nadd) + last\n        else:\n            nadd = 1\n            idx = nm.array([last])\n            conn = nm.array(conn).reshape((1, 2))\n            if edge_group is None:\n                edge_group = idx\n\n        self.edges[idx, :] = conn\n        self.edge_flag[idx] = True\n        # t_start0 = time.time()\n        # self.edge_flag_idx.extend(list(range(idx.start, idx.stop)))\n        # self.stats[\"t split 082\"] += time.time() - t_start0\n        self.edge_dir[idx] = edge_direction\n        self.edge_group[idx] = edge_group\n        # TODO change this just to array of low_or_high_resolution\n        if edge_low_or_high is not None and self._edge_weight_table is not None:\n            self.edges_weights[idx] = self._edge_weight_table[\n                edge_low_or_high, edge_direction\n            ]\n        self.lastedge += nadd\n        self.nedges += nadd"}
{"func_code_string": "def _edge_group_substitution(\n        self, ndid, nsplit, idxs, sr_tab, ndoffset, ed_remove, into_or_from\n    ):\n        \"\"\"\n        Reconnect edges.\n        :param ndid: id of low resolution edges\n        :param nsplit: number of split\n        :param idxs: indexes of low resolution\n        :param sr_tab:\n        :param ndoffset:\n        :param ed_remove:\n        :param into_or_from: if zero, connection of input edges is done. If one, connection of output edges\n        is performed.\n        :return:\n        \"\"\"\n        # this is useful for type(idxs) == np.ndarray\n        eidxs = idxs[nm.where(self.edges[idxs, 1 - into_or_from] == ndid)[0]]\n        # selected_edges = self.edges[idxs, 1 - into_or_from]\n        # selected_edges == ndid\n        # whre = nm.where(self.edges[idxs, 1 - into_or_from] == ndid)\n        # whre0 = (nm.where(self.edges[idxs, 1 - into_or_from] == ndid) == ndid)[0]\n        # eidxs = [idxs[i] for i in idxs]\n        for igrp in self.edges_by_group(eidxs):\n            if igrp.shape[0] > 1:\n                # high resolution block to high resolution block\n                # all directions are the same\n                directions = self.edge_dir[igrp[0]]\n                edge_indexes = sr_tab[directions, :].T.flatten() + ndoffset\n                # debug code\n                # if len(igrp) != len(edge_indexes):\n                #     print(\"Problem \")\n                self.edges[igrp, 1] = edge_indexes\n                if self._edge_weight_table is not None:\n                    self.edges_weights[igrp] = self._edge_weight_table[1, directions]\n            else:\n                # low res block to hi res block, if into_or_from is set to 0\n                # hig res block to low res block, if into_or_from is set to 1\n                ed_remove.append(igrp[0])\n                # number of new edges is equal to number of pixels on one side of the box (in 2D and D too)\n                nnewed = np.power(nsplit, self.data.ndim - 1)\n                muleidxs = nm.tile(igrp, nnewed)\n                # copy the low-res edge multipletime\n                newed = self.edges[muleidxs, :]\n                neweddir = self.edge_dir[muleidxs]\n                local_node_ids = sr_tab[\n                    self.edge_dir[igrp] + self.data.ndim * into_or_from, :\n                ].T.flatten()\n                # first or second (the actual) node id is substitued by new node indexes\n                newed[:, 1 - into_or_from] = local_node_ids + ndoffset\n                if self._edge_weight_table is not None:\n                    self.add_edges(\n                        newed, neweddir, self.edge_group[igrp], edge_low_or_high=1\n                    )\n                else:\n                    self.add_edges(\n                        newed, neweddir, self.edge_group[igrp], edge_low_or_high=None\n                    )\n        return ed_remove"}
{"func_code_string": "def generate_base_grid(self, vtk_filename=None):\n        \"\"\"\n        Run first step of algorithm. Next step is split_voxels\n        :param vtk_filename:\n        :return:\n        \"\"\"\n        nd, ed, ed_dir = self.gen_grid_fcn(self.data.shape, self.voxelsize)\n        self.add_nodes(nd)\n        self.add_edges(ed, ed_dir, edge_low_or_high=0)\n\n        if vtk_filename is not None:\n            self.write_vtk(vtk_filename)"}
{"func_code_string": "def split_voxels(self, vtk_filename=None):\n        \"\"\"\n        Second step of algorithm\n        :return:()\n        \"\"\"\n        self.cache = {}\n        self.stats[\"t graph 10\"] = time.time() - self.start_time\n        self.msi = MultiscaleArray(self.data.shape, block_size=self.nsplit)\n\n        # old implementation\n        # idxs = nm.where(self.data)\n        # nr, nc = self.data.shape\n        # for k, (ir, ic) in enumerate(zip(*idxs)):\n        #     ndid = ic + ir * nc\n        #     self.split_voxel(ndid, self.nsplit)\n\n        # new_implementation\n        # for ndid in np.flatnonzero(self.data):\n        #     self.split_voxel(ndid, self.nsplit)\n\n        # even newer implementation\n        self.stats[\"t graph 11\"] = time.time() - self.start_time\n        for ndid, val in enumerate(self.data.ravel()):\n            t_split_start = time.time()\n            if val == 0:\n                if self.compute_msindex:\n                    self.msi.set_block_lowres(ndid, ndid)\n                self.stats[\"t graph low\"] += time.time() - t_split_start\n            else:\n                self.split_voxel(ndid)\n                self.stats[\"t graph high\"] += time.time() - t_split_start\n\n        self.stats[\"t graph 13\"] = time.time() - self.start_time\n        self.finish()\n        if vtk_filename is not None:\n            self.write_vtk(vtk_filename)\n        self.stats[\"t graph 14\"] = time.time() - self.start_time"}
{"func_code_string": "def mul_block(self, index, val):\n        \"\"\"Multiply values in block\"\"\"\n        self._prepare_cache_slice(index)\n        self.msinds[self.cache_slice] *= val"}
{"func_code_string": "def select_from_fv_by_seeds(fv, seeds, unique_cls):\n    \"\"\"\n    Tool to make simple feature functions take features from feature array by seeds.\n    :param fv: ndarray with lineariezed feature. It's shape is MxN, where M is number of image pixels and N is number\n    of features\n    :param seeds: ndarray with seeds. Does not to be linear.\n    :param unique_cls: number of used seeds clases. Like [1, 2]\n    :return: fv_selection, seeds_selection - selection from feature vector and selection from seeds\n    \"\"\"\n    logger.debug(\"seeds\" + str(seeds))\n    # fvlin = fv.reshape(-1, int(fv.size/seeds.size))\n    expected_shape = [seeds.size, int(fv.size/seeds.size)]\n    if fv.shape[0] != expected_shape[0] or fv.shape[1] != expected_shape[1]:\n        raise AssertionError(\"Wrong shape of input feature vector array fv\")\n    # sd = seeds.reshape(-1, 1)\n    selection = np.in1d(seeds, unique_cls)\n    fv_selection = fv[selection]\n    seeds_selection = seeds.flatten()[selection]\n    # sd = sd[]\n    return fv_selection, seeds_selection"}
{"func_code_string": "def return_fv_by_seeds(fv, seeds=None, unique_cls=None):\n    \"\"\"\n    Return features selected by seeds and unique_cls or selection from features and corresponding seed classes.\n\n    :param fv: ndarray with lineariezed feature. It's shape is MxN, where M is number of image pixels and N is number\n    of features\n    :param seeds: ndarray with seeds. Does not to be linear.\n    :param unique_cls: number of used seeds clases. Like [1, 2]\n    :return: fv, sd - selection from feature vector and selection from seeds or just fv for whole image\n    \"\"\"\n    if seeds is not None:\n        if unique_cls is not None:\n            return select_from_fv_by_seeds(fv, seeds, unique_cls)\n        else:\n            raise AssertionError(\"Input unique_cls has to be not None if seeds is not None.\")\n    else:\n        return fv"}
{"func_code_string": "def expand(self, expression):\n        \"\"\"Expands logical constructions.\"\"\"\n        self.logger.debug(\"expand : expression %s\", str(expression))\n        if not is_string(expression):\n            return expression\n\n        result = self._pattern.sub(lambda var: str(self._variables[var.group(1)]), expression)\n\n        result = result.strip()\n        self.logger.debug('expand : %s - result : %s', expression, result)\n\n        if is_number(result):\n            if result.isdigit():\n                self.logger.debug('     expand is integer !!!')\n                return int(result)\n            else:\n                self.logger.debug('     expand is float !!!')\n                return float(result)\n        return result"}
{"func_code_string": "def get_gutter_client(\n        alias='default',\n        cache=CLIENT_CACHE,\n        **kwargs\n):\n    \"\"\"\n    Creates gutter clients and memoizes them in a registry for future quick access.\n\n    Args:\n        alias (str or None): Name of the client. Used for caching.\n            If name is falsy then do not use the cache.\n        cache (dict): cache to store gutter managers in.\n        **kwargs: kwargs to be passed the Manger class.\n\n    Returns (Manager):\n        A gutter client.\n\n    \"\"\"\n    from gutter.client.models import Manager\n\n    if not alias:\n        return Manager(**kwargs)\n    elif alias not in cache:\n        cache[alias] = Manager(**kwargs)\n\n    return cache[alias]"}
{"func_code_string": "def _modulo(self, decimal_argument):\n        \"\"\"\n        The mod operator is prone to floating point errors, so use decimal.\n\n        101.1 % 100\n        >>> 1.0999999999999943\n\n        decimal_context.divmod(Decimal('100.1'), 100)\n        >>> (Decimal('1'), Decimal('0.1'))\n        \"\"\"\n        _times, remainder = self._context.divmod(decimal_argument, 100)\n\n        # match the builtin % behavior by adding the N to the result if negative\n        return remainder if remainder >= 0 else remainder + 100"}
{"func_code_string": "def enabled_for(self, inpt):\n        \"\"\"\n        Checks to see if this switch is enabled for the provided input.\n\n        If ``compounded``, all switch conditions must be ``True`` for the switch\n        to be enabled.  Otherwise, *any* condition needs to be ``True`` for the\n        switch to be enabled.\n\n        The switch state is then checked to see if it is ``GLOBAL`` or\n        ``DISABLED``.  If it is not, then the switch is ``SELECTIVE`` and each\n        condition is checked.\n\n        Keyword Arguments:\n        inpt -- An instance of the ``Input`` class.\n        \"\"\"\n\n        signals.switch_checked.call(self)\n        signal_decorated = partial(self.__signal_and_return, inpt)\n\n        if self.state is self.states.GLOBAL:\n            return signal_decorated(True)\n        elif self.state is self.states.DISABLED:\n            return signal_decorated(False)\n\n        conditions_dict = ConditionsDict.from_conditions_list(self.conditions)\n        conditions = conditions_dict.get_by_input(inpt)\n\n        if conditions:\n            result = self.__enabled_func(\n                cond.call(inpt)\n                for cond\n                in conditions\n                if cond.argument(inpt).applies\n            )\n        else:\n            result = None\n\n        return signal_decorated(result)"}
{"func_code_string": "def call(self, inpt):\n        \"\"\"\n        Returns if the condition applies to the ``inpt``.\n\n        If the class ``inpt`` is an instance of is not the same class as the\n        condition's own ``argument``, then ``False`` is returned.  This also\n        applies to the ``NONE`` input.\n\n        Otherwise, ``argument`` is called, with ``inpt`` as the instance and\n        the value is compared to the ``operator`` and the Value is returned.  If\n        the condition is ``negative``, then then ``not`` the value is returned.\n\n        Keyword Arguments:\n        inpt -- An instance of the ``Input`` class.\n        \"\"\"\n        if inpt is Manager.NONE_INPUT:\n            return False\n\n        # Call (construct) the argument with the input object\n        argument_instance = self.argument(inpt)\n\n        if not argument_instance.applies:\n            return False\n\n        application = self.__apply(argument_instance, inpt)\n\n        if self.negative:\n            application = not application\n\n        return application"}
{"func_code_string": "def switches(self):\n        \"\"\"\n        List of all switches currently registered.\n        \"\"\"\n        results = [\n            switch for name, switch in self.storage.iteritems()\n            if name.startswith(self.__joined_namespace)\n        ]\n\n        return results"}
{"func_code_string": "def switch(self, name):\n        \"\"\"\n        Returns the switch with the provided ``name``.\n\n        If ``autocreate`` is set to ``True`` and no switch with that name\n        exists, a ``DISABLED`` switch will be with that name.\n\n        Keyword Arguments:\n        name -- A name of a switch.\n        \"\"\"\n        try:\n            switch = self.storage[self.__namespaced(name)]\n        except KeyError:\n            if not self.autocreate:\n                raise ValueError(\"No switch named '%s' registered in '%s'\" % (name, self.namespace))\n\n            switch = self.__create_and_register_disabled_switch(name)\n\n        switch.manager = self\n        return switch"}
{"func_code_string": "def register(self, switch, signal=signals.switch_registered):\n        '''\n        Register a switch and persist it to the storage.\n        '''\n        if not switch.name:\n            raise ValueError('Switch name cannot be blank')\n\n        switch.manager = self\n        self.__persist(switch)\n\n        signal.call(switch)"}
{"func_code_string": "def verify(obj, times=1, atleast=None, atmost=None, between=None,\n           inorder=False):\n    \"\"\"Central interface to verify interactions.\n\n    `verify` uses a fluent interface::\n\n        verify(<obj>, times=2).<method_name>(<args>)\n\n    `args` can be as concrete as necessary. Often a catch-all is enough,\n    especially if you're working with strict mocks, bc they throw at call\n    time on unwanted, unconfigured arguments::\n\n        from mockito import ANY, ARGS, KWARGS\n        when(manager).add_tasks(1, 2, 3)\n        ...\n        # no need to duplicate the specification; every other argument pattern\n        # would have raised anyway.\n        verify(manager).add_tasks(1, 2, 3)  # duplicates `when`call\n        verify(manager).add_tasks(*ARGS)\n        verify(manager).add_tasks(...)       # Py3\n        verify(manager).add_tasks(Ellipsis)  # Py2\n\n    \"\"\"\n\n    if isinstance(obj, str):\n        obj = get_obj(obj)\n\n    verification_fn = _get_wanted_verification(\n        times=times, atleast=atleast, atmost=atmost, between=between)\n    if inorder:\n        verification_fn = verification.InOrder(verification_fn)\n\n    # FIXME?: Catch error if obj is neither a Mock nor a known stubbed obj\n    theMock = _get_mock_or_raise(obj)\n\n    class Verify(object):\n        def __getattr__(self, method_name):\n            return invocation.VerifiableInvocation(\n                theMock, method_name, verification_fn)\n\n    return Verify()"}
{"func_code_string": "def when(obj, strict=None):\n    \"\"\"Central interface to stub functions on a given `obj`\n\n    `obj` should be a module, a class or an instance of a class; it can be\n    a Dummy you created with :func:`mock`. ``when`` exposes a fluent interface\n    where you configure a stub in three steps::\n\n        when(<obj>).<method_name>(<args>).thenReturn(<value>)\n\n    Compared to simple *patching*, stubbing in mockito requires you to specify\n    conrete `args` for which the stub will answer with a concrete `<value>`.\n    All invocations that do not match this specific call signature will be\n    rejected. They usually throw at call time.\n\n    Stubbing in mockito's sense thus means not only to get rid of unwanted\n    side effects, but effectively to turn function calls into constants.\n\n    E.g.::\n\n        # Given ``dog`` is an instance of a ``Dog``\n        when(dog).bark('Grrr').thenReturn('Wuff')\n        when(dog).bark('Miau').thenRaise(TypeError())\n\n        # With this configuration set up:\n        assert dog.bark('Grrr') == 'Wuff'\n        dog.bark('Miau')  # will throw TypeError\n        dog.bark('Wuff')  # will throw unwanted interaction\n\n    Stubbing can effectively be used as monkeypatching; usage shown with\n    the `with` context managing::\n\n        with when(os.path).exists('/foo').thenReturn(True):\n            ...\n\n    Most of the time verifying your interactions is not necessary, because\n    your code under tests implicitly verifies the return value by evaluating\n    it. See :func:`verify` if you need to, see also :func:`expect` to setup\n    expected call counts up front.\n\n    If your function is pure side effect and does not return something, you\n    can omit the specific answer. The default then is `None`::\n\n        when(manager).do_work()\n\n    `when` verifies the method name, the expected argument signature, and the\n    actual, factual arguments your code under test uses against the original\n    object and its function so its easier to spot changing interfaces.\n\n    Sometimes it's tedious to spell out all arguments::\n\n        from mockito import ANY, ARGS, KWARGS\n        when(requests).get('http://example.com/', **KWARGS).thenReturn(...)\n        when(os.path).exists(ANY)\n        when(os.path).exists(ANY(str))\n\n    .. note:: You must :func:`unstub` after stubbing, or use `with`\n        statement.\n\n    Set ``strict=False`` to bypass the function signature checks.\n\n    See related :func:`when2` which has a more pythonic interface.\n\n    \"\"\"\n\n    if isinstance(obj, str):\n        obj = get_obj(obj)\n\n    if strict is None:\n        strict = True\n    theMock = _get_mock(obj, strict=strict)\n\n    class When(object):\n        def __getattr__(self, method_name):\n            return invocation.StubbedInvocation(\n                theMock, method_name, strict=strict)\n\n    return When()"}
{"func_code_string": "def when2(fn, *args, **kwargs):\n    \"\"\"Stub a function call with the given arguments\n\n    Exposes a more pythonic interface than :func:`when`. See :func:`when` for\n    more documentation.\n\n    Returns `AnswerSelector` interface which exposes `thenReturn`,\n    `thenRaise`, and `thenAnswer` as usual. Always `strict`.\n\n    Usage::\n\n        # Given `dog` is an instance of a `Dog`\n        when2(dog.bark, 'Miau').thenReturn('Wuff')\n\n    .. note:: You must :func:`unstub` after stubbing, or use `with`\n        statement.\n\n    \"\"\"\n    obj, name = get_obj_attr_tuple(fn)\n    theMock = _get_mock(obj, strict=True)\n    return invocation.StubbedInvocation(theMock, name)(*args, **kwargs)"}
{"func_code_string": "def patch(fn, attr_or_replacement, replacement=None):\n    \"\"\"Patch/Replace a function.\n\n    This is really like monkeypatching, but *note* that all interactions\n    will be recorded and can be verified. That is, using `patch` you stay in\n    the domain of mockito.\n\n    Two ways to call this. Either::\n\n        patch(os.path.exists, lambda str: True)  # two arguments\n        # OR\n        patch(os.path, 'exists', lambda str: True)  # three arguments\n\n    If called with three arguments, the mode is *not* strict to allow *adding*\n    methods. If called with two arguments, mode is always `strict`.\n\n    .. note:: You must :func:`unstub` after stubbing, or use `with`\n        statement.\n\n    \"\"\"\n    if replacement is None:\n        replacement = attr_or_replacement\n        return when2(fn, Ellipsis).thenAnswer(replacement)\n    else:\n        obj, name = fn, attr_or_replacement\n        theMock = _get_mock(obj, strict=True)\n        return invocation.StubbedInvocation(\n            theMock, name, strict=False)(Ellipsis).thenAnswer(replacement)"}
{"func_code_string": "def expect(obj, strict=None,\n           times=None, atleast=None, atmost=None, between=None):\n    \"\"\"Stub a function call, and set up an expected call count.\n\n    Usage::\n\n        # Given `dog` is an instance of a `Dog`\n        expect(dog, times=1).bark('Wuff').thenReturn('Miau')\n        dog.bark('Wuff')\n        dog.bark('Wuff')  # will throw at call time: too many invocations\n\n        # maybe if you need to ensure that `dog.bark()` was called at all\n        verifyNoUnwantedInteractions()\n\n    .. note:: You must :func:`unstub` after stubbing, or use `with`\n        statement.\n\n    See :func:`when`, :func:`when2`, :func:`verifyNoUnwantedInteractions`\n\n    \"\"\"\n    if strict is None:\n        strict = True\n    theMock = _get_mock(obj, strict=strict)\n\n    verification_fn = _get_wanted_verification(\n        times=times, atleast=atleast, atmost=atmost, between=between)\n\n    class Expect(object):\n        def __getattr__(self, method_name):\n            return invocation.StubbedInvocation(\n                theMock, method_name, verification=verification_fn,\n                strict=strict)\n\n    return Expect()"}
{"func_code_string": "def unstub(*objs):\n    \"\"\"Unstubs all stubbed methods and functions\n\n    If you don't pass in any argument, *all* registered mocks and\n    patched modules, classes etc. will be unstubbed.\n\n    Note that additionally, the underlying registry will be cleaned.\n    After an `unstub` you can't :func:`verify` anymore because all\n    interactions will be forgotten.\n    \"\"\"\n\n    if objs:\n        for obj in objs:\n            mock_registry.unstub(obj)\n    else:\n        mock_registry.unstub_all()"}
{"func_code_string": "def verifyZeroInteractions(*objs):\n    \"\"\"Verify that no methods have been called on given objs.\n\n    Note that strict mocks usually throw early on unexpected, unstubbed\n    invocations. Partial mocks ('monkeypatched' objects or modules) do not\n    support this functionality at all, bc only for the stubbed invocations\n    the actual usage gets recorded. So this function is of limited use,\n    nowadays.\n\n    \"\"\"\n    for obj in objs:\n        theMock = _get_mock_or_raise(obj)\n\n        if len(theMock.invocations) > 0:\n            raise VerificationError(\n                \"\\nUnwanted interaction: %s\" % theMock.invocations[0])"}
{"func_code_string": "def verifyNoUnwantedInteractions(*objs):\n    \"\"\"Verifies that expectations set via `expect` are met\n\n    E.g.::\n\n        expect(os.path, times=1).exists(...).thenReturn(True)\n        os.path('/foo')\n        verifyNoUnwantedInteractions(os.path)  # ok, called once\n\n    If you leave out the argument *all* registered objects will\n    be checked.\n\n    .. note:: **DANGERZONE**: If you did not :func:`unstub` correctly,\n        it is possible that old registered mocks, from other tests\n        leak.\n\n    See related :func:`expect`\n    \"\"\"\n\n    if objs:\n        theMocks = map(_get_mock_or_raise, objs)\n    else:\n        theMocks = mock_registry.get_registered_mocks()\n\n    for mock in theMocks:\n        for i in mock.stubbed_invocations:\n            i.verify()"}
{"func_code_string": "def verifyStubbedInvocationsAreUsed(*objs):\n    \"\"\"Ensure stubs are actually used.\n\n    This functions just ensures that stubbed methods are actually used. Its\n    purpose is to detect interface changes after refactorings. It is meant\n    to be invoked usually without arguments just before :func:`unstub`.\n\n    \"\"\"\n    if objs:\n        theMocks = map(_get_mock_or_raise, objs)\n    else:\n        theMocks = mock_registry.get_registered_mocks()\n\n\n    for mock in theMocks:\n        for i in mock.stubbed_invocations:\n            if not i.allow_zero_invocations and i.used < len(i.answers):\n                raise VerificationError(\"\\nUnused stub: %s\" % i)"}
{"func_code_string": "def get_function_host(fn):\n    \"\"\"Destructure a given function into its host and its name.\n\n    The 'host' of a function is a module, for methods it is usually its\n    instance or its class. This is safe only for methods, for module wide,\n    globally declared names it must be considered experimental.\n\n    For all reasonable fn: ``getattr(*get_function_host(fn)) == fn``\n\n    Returns tuple (host, fn-name)\n    Otherwise should raise TypeError\n    \"\"\"\n\n    obj = None\n    try:\n        name = fn.__name__\n        obj = fn.__self__\n    except AttributeError:\n        pass\n\n    if obj is None:\n        # Due to how python imports work, everything that is global on a module\n        # level must be regarded as not safe here. For now, we go for the extra\n        # mile, TBC, because just specifying `os.path.exists` would be 'cool'.\n        #\n        # TLDR;:\n        # E.g. `inspect.getmodule(os.path.exists)` returns `genericpath` bc\n        # that's where `exists` is defined and comes from. But from the point\n        # of view of the user `exists` always comes and is used from `os.path`\n        # which points e.g. to `ntpath`. We thus must patch `ntpath`.\n        # But that's the same for most imports::\n        #\n        #     # b.py\n        #     from a import foo\n        #\n        # Now asking `getmodule(b.foo)` it tells you `a`, but we access and use\n        # `b.foo` and we therefore must patch `b`.\n\n        obj, name = find_invoking_frame_and_try_parse()\n        # safety check!\n        assert getattr(obj, name) == fn\n\n\n    return obj, name"}
{"func_code_string": "def get_obj(path):\n    \"\"\"Return obj for given dotted path.\n\n    Typical inputs for `path` are 'os' or 'os.path' in which case you get a\n    module; or 'os.path.exists' in which case you get a function from that\n    module.\n\n    Just returns the given input in case it is not a str.\n\n    Note: Relative imports not supported.\n    Raises ImportError or AttributeError as appropriate.\n\n    \"\"\"\n    # Since we usually pass in mocks here; duck typing is not appropriate\n    # (mocks respond to every attribute).\n    if not isinstance(path, str):\n        return path\n\n    if path.startswith('.'):\n        raise TypeError('relative imports are not supported')\n\n    parts = path.split('.')\n    head, tail = parts[0], parts[1:]\n\n    obj = importlib.import_module(head)\n\n    # Normally a simple reduce, but we go the extra mile\n    # for good exception messages.\n    for i, name in enumerate(tail):\n        try:\n            obj = getattr(obj, name)\n        except AttributeError:\n            # Note the [:i] instead of [:i+1], so we get the path just\n            # *before* the AttributeError, t.i. the part of it that went ok.\n            module = '.'.join([head] + tail[:i])\n            try:\n                importlib.import_module(module)\n            except ImportError:\n                raise AttributeError(\n                    \"object '%s' has no attribute '%s'\" % (module, name))\n            else:\n                raise AttributeError(\n                    \"module '%s' has no attribute '%s'\" % (module, name))\n    return obj"}
{"func_code_string": "def get_obj_attr_tuple(path):\n    \"\"\"Split path into (obj, attribute) tuple.\n\n    Given `path` is 'os.path.exists' will thus return `(os.path, 'exists')`\n\n    If path is not a str, delegates to `get_function_host(path)`\n\n    \"\"\"\n    if not isinstance(path, str):\n        return get_function_host(path)\n\n    if path.startswith('.'):\n        raise TypeError('relative imports are not supported')\n\n    try:\n        leading, end = path.rsplit('.', 1)\n    except ValueError:\n        raise TypeError('path must have dots')\n\n    return get_obj(leading), end"}
{"func_code_string": "def spy(object):\n    \"\"\"Spy an object.\n\n    Spying means that all functions will behave as before, so they will\n    be side effects, but the interactions can be verified afterwards.\n\n    Returns Dummy-like, almost empty object as proxy to `object`.\n\n    The *returned* object must be injected and used by the code under test;\n    after that all interactions can be verified as usual.\n    T.i. the original object **will not be patched**, and has no further\n    knowledge as before.\n\n    E.g.::\n\n        import time\n        time = spy(time)\n        # inject time\n        do_work(..., time)\n        verify(time).time()\n\n    \"\"\"\n    if inspect.isclass(object) or inspect.ismodule(object):\n        class_ = None\n    else:\n        class_ = object.__class__\n\n    class Spy(_Dummy):\n        if class_:\n            __class__ = class_\n\n        def __getattr__(self, method_name):\n            return RememberedProxyInvocation(theMock, method_name)\n\n        def __repr__(self):\n            name = 'Spied'\n            if class_:\n                name += class_.__name__\n            return \"<%s id=%s>\" % (name, id(self))\n\n\n    obj = Spy()\n    theMock = Mock(obj, strict=True, spec=object)\n\n    mock_registry.register(obj, theMock)\n    return obj"}
{"func_code_string": "def spy2(fn):  # type: (...) -> None\n    \"\"\"Spy usage of given `fn`.\n\n    Patches the module, class or object `fn` lives in, so that all\n    interactions can be recorded; otherwise executes `fn` as before, so\n    that all side effects happen as before.\n\n    E.g.::\n\n        import time\n        spy(time.time)\n        do_work(...)  # nothing injected, uses global patched `time` module\n        verify(time).time()\n\n    Note that builtins often cannot be patched because they're read-only.\n\n\n    \"\"\"\n    if isinstance(fn, str):\n        answer = get_obj(fn)\n    else:\n        answer = fn\n\n    when2(fn, Ellipsis).thenAnswer(answer)"}
{"func_code_string": "def mock(config_or_spec=None, spec=None, strict=OMITTED):\n    \"\"\"Create 'empty' objects ('Mocks').\n\n    Will create an empty unconfigured object, that you can pass\n    around. All interactions (method calls) will be recorded and can be\n    verified using :func:`verify` et.al.\n\n    A plain `mock()` will be not `strict`, and thus all methods regardless\n    of the arguments will return ``None``.\n\n    .. note:: Technically all attributes will return an internal interface.\n        Because of that a simple ``if mock().foo:`` will surprisingly pass.\n\n    If you set strict to ``True``: ``mock(strict=True)`` all unexpected\n    interactions will raise an error instead.\n\n    You configure a mock using :func:`when`, :func:`when2` or :func:`expect`.\n    You can also very conveniently just pass in a dict here::\n\n        response = mock({'text': 'ok', 'raise_for_status': lambda: None})\n\n    You can also create an empty Mock which is specced against a given\n    `spec`: ``mock(requests.Response)``. These mock are by default strict,\n    thus they raise if you want to stub a method, the spec does not implement.\n    Mockito will also match the function signature.\n\n    You can pre-configure a specced mock as well::\n\n        response = mock({'json': lambda: {'status': 'Ok'}},\n                        spec=requests.Response)\n\n    Mocks are by default callable. Configure the callable behavior using\n    `when`::\n\n        dummy = mock()\n        when(dummy).__call_(1).thenReturn(2)\n\n    All other magic methods must be configured this way or they will raise an\n    AttributeError.\n\n\n    See :func:`verify` to verify your interactions after usage.\n\n    \"\"\"\n\n    if type(config_or_spec) is dict:\n        config = config_or_spec\n    else:\n        config = {}\n        spec = config_or_spec\n\n    if strict is OMITTED:\n        strict = False if spec is None else True\n\n\n    class Dummy(_Dummy):\n        if spec:\n            __class__ = spec  # make isinstance work\n\n        def __getattr__(self, method_name):\n            if strict:\n                raise AttributeError(\n                    \"'Dummy' has no attribute %r configured\" % method_name)\n            return functools.partial(\n                remembered_invocation_builder, theMock, method_name)\n\n        def __repr__(self):\n            name = 'Dummy'\n            if spec:\n                name += spec.__name__\n            return \"<%s id=%s>\" % (name, id(self))\n\n\n    # That's a tricky one: The object we will return is an *instance* of our\n    # Dummy class, but the mock we register will point and patch the class.\n    # T.i. so that magic methods (`__call__` etc.) can be configured.\n    obj = Dummy()\n    theMock = Mock(Dummy, strict=strict, spec=spec)\n\n    for n, v in config.items():\n        if inspect.isfunction(v):\n            invocation.StubbedInvocation(theMock, n)(Ellipsis).thenAnswer(v)\n        else:\n            setattr(obj, n, v)\n\n    mock_registry.register(obj, theMock)\n    return obj"}
{"func_code_string": "def importPuppetClasses(self, smartProxyId):\n        \"\"\" Function importPuppetClasses\n        Force the reload of puppet classes\n\n        @param smartProxyId: smartProxy Id\n        @return RETURN: the API result\n        \"\"\"\n        return self.api.create('{}/{}/import_puppetclasses'\n                               .format(self.objName, smartProxyId), '{}')"}
{"func_code_string": "def get_templates(model):\n    \"\"\" Return a list of templates usable by a model. \"\"\"\n    for template_name, template in templates.items():\n        if issubclass(template.model, model):\n            yield (template_name, template.layout._meta.verbose_name)"}
{"func_code_string": "def attach(*layouts, **kwargs):\n    \"\"\"\n    Registers the given layout(s) classes\n    admin site:\n\n    @pages.register(Page)\n    class Default(PageLayout):\n        pass\n    \"\"\"\n\n    def _model_admin_wrapper(layout_class):\n        register(layout_class, layouts[0])\n        return layout_class\n    return _model_admin_wrapper"}
{"func_code_string": "def enhance(self):\n        \"\"\" Function enhance\n        Enhance the object with new item or enhanced items\n        \"\"\"\n        self.update({'os_default_templates':\n                     SubDict(self.api, self.objName,\n                             self.payloadObj, self.key,\n                             SubItemOsDefaultTemplate)})\n        self.update({'config_templates':\n                     SubDict(self.api, self.objName,\n                             self.payloadObj, self.key,\n                             SubItemConfigTemplate)})\n        self.update({'ptables':\n                     SubDict(self.api, self.objName,\n                             self.payloadObj, self.key,\n                             SubItemPTable)})\n        self.update({'media':\n                     SubDict(self.api, self.objName,\n                             self.payloadObj, self.key,\n                             SubItemMedia)})\n        self.update({'architectures':\n                     SubDict(self.api, self.objName,\n                             self.payloadObj, self.key,\n                             SubItemArchitecture)})"}
{"func_code_string": "def get_api_envs():\n    \"\"\"Get required API keys from environment variables.\"\"\"\n    client_id = os.environ.get('CLIENT_ID')\n    user_id = os.environ.get('USER_ID')\n    if not client_id or not user_id:\n        raise ValueError('API keys are not found in the environment')\n    return client_id, user_id"}
{"func_code_string": "def api_call(method, end_point, params=None, client_id=None, access_token=None):\n    \"\"\"Call given API end_point with API keys.\n    :param method: HTTP method (e.g. 'get', 'delete').\n    :param end_point: API endpoint (e.g. 'users/john/sets').\n    :param params: Dictionary to be sent in the query string (e.g. {'myparam': 'myval'})\n    :param client_id: Quizlet client ID as string.\n    :param access_token: Quizlet access token as string.\n    client_id and access_token are mutually exclusive but mandatory.\n    \"\"\"\n    if bool(client_id) == bool(access_token):\n        raise ValueError('Either client_id or access_token')\n\n    url = 'https://api.quizlet.com/2.0/{}'.format(end_point)\n\n    if not params:\n        params = {}\n    if client_id:\n        params['client_id'] = client_id\n\n    headers = {'Authorization': 'Bearer {}'.format(access_token)} if access_token else None\n\n    response = requests.request(method, url, params=params, headers=headers)\n\n    if int(response.status_code / 100) != 2:\n        error_title = ''\n        try:\n            error_title += ', ' + response.json()['error_title']\n        except ValueError:\n            pass\n        except KeyError:\n            pass\n        raise ValueError(\n            '{} returned {}{}'.format(url, response.status_code, error_title)\n        )\n\n    try:\n        return response.json()\n    except json.decoder.JSONDecodeError:\n        pass"}
{"func_code_string": "def request_upload_secret(self, secret_id):\n        \"\"\"\n        :return: json with \"keyId\" as secret and \"url\" for posting key\n        \"\"\"\n        return self._router.post_request_upload_secret(org_id=self.organizationId,\n                                                       instance_id=self.instanceId,\n                                                       secret_id=secret_id).json()"}
{"func_code_string": "def checkAndCreate(self, key, payload, domainId):\n        \"\"\" Function checkAndCreate\n        Check if a subnet exists and create it if not\n\n        @param key: The targeted subnet\n        @param payload: The targeted subnet description\n        @param domainId: The domainId to be attached wiuth the subnet\n        @return RETURN: The id of the subnet\n        \"\"\"\n        if key not in self:\n            self[key] = payload\n        oid = self[key]['id']\n        if not oid:\n            return False\n        #~ Ensure subnet contains the domain\n        subnetDomainIds = []\n        for domain in self[key]['domains']:\n            subnetDomainIds.append(domain['id'])\n        if domainId not in subnetDomainIds:\n            subnetDomainIds.append(domainId)\n            self[key][\"domain_ids\"] = subnetDomainIds\n            if len(self[key][\"domains\"]) is not len(subnetDomainIds):\n                return False\n        return oid"}
{"func_code_string": "def removeDomain(self, subnetId, domainId):\n        \"\"\" Function removeDomain\n        Delete a domain from a subnet\n\n        @param subnetId: The subnet Id\n        @param domainId: The domainId to be attached wiuth the subnet\n        @return RETURN: boolean\n        \"\"\"\n        subnetDomainIds = []\n        for domain in self[subnetId]['domains']:\n            subnetDomainIds.append(domain['id'])\n        subnetDomainIds.remove(domainId)\n        self[subnetId][\"domain_ids\"] = subnetDomainIds\n        return len(self[subnetId][\"domains\"]) is len(subnetDomainIds)"}
{"func_code_string": "def exclusive(via=threading.Lock):\n    \"\"\"\n    Mark a callable as exclusive\n\n    :param via: factory for a Lock to guard the callable\n\n    Guards the callable against being entered again before completion.\n    Explicitly raises a :py:exc:`RuntimeError` on violation.\n\n    :note: If applied to a method, it is exclusive across all instances.\n    \"\"\"\n    def make_exclusive(fnc):\n        fnc_guard = via()\n\n        @functools.wraps(fnc)\n        def exclusive_call(*args, **kwargs):\n            if fnc_guard.acquire(blocking=False):\n                try:\n                    return fnc(*args, **kwargs)\n                finally:\n                    fnc_guard.release()\n            else:\n                raise RuntimeError('exclusive call to %s violated')\n        return exclusive_call\n    return make_exclusive"}
{"func_code_string": "def service(flavour):\n    r\"\"\"\n    Mark a class as implementing a Service\n\n    Each Service class must have a ``run`` method, which does not take any arguments.\n    This method is :py:meth:`~.ServiceRunner.adopt`\\ ed after the daemon starts, unless\n\n    * the Service has been garbage collected, or\n    * the ServiceUnit has been :py:meth:`~.ServiceUnit.cancel`\\ ed.\n\n    For each service instance, its :py:class:`~.ServiceUnit` is available at ``service_instance.__service_unit__``.\n    \"\"\"\n    def service_unit_decorator(raw_cls):\n        __new__ = raw_cls.__new__\n\n        def __new_service__(cls, *args, **kwargs):\n            if __new__ is object.__new__:\n                self = __new__(cls)\n            else:\n                self = __new__(cls, *args, **kwargs)\n            service_unit = ServiceUnit(self, flavour)\n            self.__service_unit__ = service_unit\n            return self\n\n        raw_cls.__new__ = __new_service__\n        if raw_cls.run.__doc__ is None:\n            raw_cls.run.__doc__ = \"Service entry point\"\n        return raw_cls\n    return service_unit_decorator"}
{"func_code_string": "def execute(self, payload, *args, flavour: ModuleType, **kwargs):\n        \"\"\"\n        Synchronously run ``payload`` and provide its output\n\n        If ``*args*`` and/or ``**kwargs`` are provided, pass them to ``payload`` upon execution.\n        \"\"\"\n        if args or kwargs:\n            payload = functools.partial(payload, *args, **kwargs)\n        return self._meta_runner.run_payload(payload, flavour=flavour)"}
{"func_code_string": "def adopt(self, payload, *args, flavour: ModuleType, **kwargs):\n        \"\"\"\n        Concurrently run ``payload`` in the background\n\n        If ``*args*`` and/or ``**kwargs`` are provided, pass them to ``payload`` upon execution.\n        \"\"\"\n        if args or kwargs:\n            payload = functools.partial(payload, *args, **kwargs)\n        self._meta_runner.register_payload(payload, flavour=flavour)"}
{"func_code_string": "def accept(self):\n        \"\"\"\n        Start accepting synchronous, asynchronous and service payloads\n\n        Since services are globally defined, only one :py:class:`ServiceRunner`\n        may :py:meth:`accept` payloads at any time.\n        \"\"\"\n        if self._meta_runner:\n            raise RuntimeError('payloads scheduled for %s before being started' % self)\n        self._must_shutdown = False\n        self._logger.info('%s starting', self.__class__.__name__)\n        # force collecting objects so that defunct, migrated and overwritten services are destroyed now\n        gc.collect()\n        self._adopt_services()\n        self.adopt(self._accept_services, flavour=trio)\n        self._meta_runner.run()"}
{"func_code_string": "def shutdown(self):\n        \"\"\"Shutdown the accept loop and stop running payloads\"\"\"\n        self._must_shutdown = True\n        self._is_shutdown.wait()\n        self._meta_runner.stop()"}
{"func_code_string": "def milestones(ctx, list, close):\n    \"\"\"View/edit/close milestones on github\n    \"\"\"\n    repos = get_repos(ctx.parent.agile.get('labels'))\n    if list:\n        _list_milestones(repos)\n    elif close:\n        click.echo('Closing milestones \"%s\"' % close)\n        _close_milestone(repos, close)\n    else:\n        click.echo(ctx.get_help())"}
{"func_code_string": "def start_console(local_vars={}):\n    '''Starts a console; modified from code.interact'''\n    transforms.CONSOLE_ACTIVE = True\n    transforms.remove_not_allowed_in_console()\n    sys.ps1 = prompt\n    console = ExperimentalInteractiveConsole(locals=local_vars)\n    console.interact(banner=banner)"}
{"func_code_string": "def push(self, line):\n        \"\"\"Transform and push a line to the interpreter.\n\n        The line should not have a trailing newline; it may have\n        internal newlines.  The line is appended to a buffer and the\n        interpreter's runsource() method is called with the\n        concatenated contents of the buffer as source.  If this\n        indicates that the command was executed or invalid, the buffer\n        is reset; otherwise, the command is incomplete, and the buffer\n        is left as it was after the line was appended.  The return\n        value is 1 if more input is required, 0 if the line was dealt\n        with in some way (this is the same as runsource()).\n\n        \"\"\"\n        if transforms.FROM_EXPERIMENTAL.match(line):\n            transforms.add_transformers(line)\n            self.buffer.append(\"\\n\")\n        else:\n            self.buffer.append(line)\n\n        add_pass = False\n        if line.rstrip(' ').endswith(\":\"):\n            add_pass = True\n        source = \"\\n\".join(self.buffer)\n        if add_pass:\n            source += \"pass\"\n        source = transforms.transform(source)\n        if add_pass:\n            source = source.rstrip(' ')\n            if source.endswith(\"pass\"):\n                source = source[:-4]\n\n        # some transformations may strip an empty line meant to end a block\n        if not self.buffer[-1]:\n            source += \"\\n\"\n        try:\n            more = self.runsource(source, self.filename)\n        except SystemExit:\n            os._exit(1)\n\n        if not more:\n            self.resetbuffer()\n        return more"}
{"func_code_string": "def dump(obj, f, preserve=False):\n    \"\"\"Write dict object into file\n\n    :param obj: the object to be dumped into toml\n    :param f: the file object\n    :param preserve: optional flag to preserve the inline table in result\n    \"\"\"\n    if not f.write:\n        raise TypeError('You can only dump an object into a file object')\n    encoder = Encoder(f, preserve=preserve)\n    return encoder.write_dict(obj)"}
{"func_code_string": "def dumps(obj, preserve=False):\n    \"\"\"Stringifies a dict as toml\n\n    :param obj: the object to be dumped into toml\n    :param preserve: optional flag to preserve the inline table in result\n    \"\"\"\n    f = StringIO()\n    dump(obj, f, preserve)\n    return f.getvalue()"}
{"func_code_string": "def license_loader(lic_dir=LIC_DIR):\n    \"\"\"Loads licenses from the given directory.\"\"\"\n    lics = []\n    for ln in os.listdir(lic_dir):\n        lp = os.path.join(lic_dir, ln)\n        with open(lp) as lf:\n            txt = lf.read()\n            lic = License(txt)\n            lics.append(lic)\n    return lics"}
{"func_code_string": "def get_vector(self, max_choice=3):\n        \"\"\"Return pseudo-choice vectors.\"\"\"\n        vec = {}\n        for dim in ['forbidden', 'required', 'permitted']:\n            if self.meta[dim] is None:\n                continue\n            dim_vec = map(lambda x: (x, max_choice), self.meta[dim])\n            vec[dim] = dict(dim_vec)\n        return vec"}
{"func_code_string": "def entity(ctx, debug, uncolorize, **kwargs):\n    \"\"\"\n    CLI for tonomi.com using contrib-python-qubell-client\n\n    To enable completion:\n\n      eval \"$(_NOMI_COMPLETE=source nomi)\"\n    \"\"\"\n    global PROVIDER_CONFIG\n\n    if debug:\n        log.basicConfig(level=log.DEBUG)\n        log.getLogger(\"requests.packages.urllib3.connectionpool\").setLevel(log.DEBUG)\n    for (k, v) in kwargs.iteritems():\n        if v:\n            QUBELL[k] = v\n    PROVIDER_CONFIG = {\n        'configuration.provider': PROVIDER['provider_type'],\n        'configuration.legacy-regions': PROVIDER['provider_region'],\n        'configuration.endpoint-url': '',\n        'configuration.legacy-security-group': '',\n        'configuration.identity': PROVIDER['provider_identity'],\n        'configuration.credential': PROVIDER['provider_credential']\n    }\n\n    class UserContext(object):\n        def __init__(self):\n            self.platform = None\n            self.unauthenticated_platform = None\n            self.colorize = not (uncolorize)\n\n        def get_platform(self):\n            if not self.platform:\n                assert QUBELL[\"tenant\"], \"No platform URL provided. Set QUBELL_TENANT or use --tenant option.\"\n                if not QUBELL[\"token\"]:\n                    assert QUBELL[\"user\"], \"No username. Set QUBELL_USER or use --user option.\"\n                    assert QUBELL[\"password\"], \"No password provided. Set QUBELL_PASSWORD or use --password option.\"\n\n                self.platform = QubellPlatform.connect(\n                    tenant=QUBELL[\"tenant\"],\n                    user=QUBELL[\"user\"],\n                    password=QUBELL[\"password\"],\n                    token=QUBELL[\"token\"])\n            return self.platform\n\n        def get_unauthenticated_platform(self):\n            if not self.unauthenticated_platform:\n                assert QUBELL[\"tenant\"], \"No platform URL provided. Set QUBELL_TENANT or use --tenant option.\"\n\n                self.unauthenticated_platform = QubellPlatform.connect(tenant=QUBELL[\"tenant\"])\n\n            return self.unauthenticated_platform\n\n    ctx = click.get_current_context()\n    ctx.obj = UserContext()"}
{"func_code_string": "def import_app(files, category, overwrite, id, name):\n    \"\"\" Upload application from file.\n\n    By default, file name will be used as application name, with \"-vXX.YYY\" suffix stripped.\n    Application is looked up by one of these classifiers, in order of priority:\n    app-id, app-name, filename.\n\n    If app-id is provided, looks up existing application and updates its manifest.\n    If app-id is NOT specified, looks up by name, or creates new application.\n\n    \"\"\"\n    platform = _get_platform()\n    org = platform.get_organization(QUBELL[\"organization\"])\n    if category:\n        category = org.categories[category]\n    regex = re.compile(r\"^(.*?)(-v(\\d+)|)\\.[^.]+$\")\n    if (id or name) and len(files) > 1:\n        raise Exception(\"--id and --name are supported only for single-file mode\")\n\n    for filename in files:\n        click.echo(\"Importing \" + filename, nl=False)\n        if not name:\n            match = regex.match(basename(filename))\n            if not match:\n                click.echo(_color(\"RED\", \"FAIL\") + \" unknown filename format\")\n                break\n            name = regex.match(basename(filename)).group(1)\n        click.echo(\" => \", nl=False)\n        app = None\n        try:\n            app = org.get_application(id=id, name=name)\n            if app and not overwrite:\n                click.echo(\"%s %s already exists %s\" % (\n                    app.id, _color(\"BLUE\", app and app.name or name), _color(\"RED\", \"FAIL\")))\n                break\n        except NotFoundError:\n            if id:\n                click.echo(\"%s %s not found %s\" % (\n                    id or \"\", _color(\"BLUE\", app and app.name or name), _color(\"RED\", \"FAIL\")))\n                break\n        click.echo(_color(\"BLUE\", app and app.name or name) + \" \", nl=False)\n        try:\n            with file(filename, \"r\") as f:\n                if app:\n                    app.update(name=app.name,\n                               category=category and category.id or app.category,\n                               manifest=Manifest(content=f.read()))\n                else:\n                    app = org.application(id=id, name=name, manifest=Manifest(content=f.read()))\n                    if category:\n                        app.update(category=category.id)\n            click.echo(app.id + _color(\"GREEN\", \" OK\"))\n        except IOError as e:\n            click.echo(_color(\"RED\", \" FAIL\") + \" \" + e.message)\n            break"}
{"func_code_string": "def show_account():\n    \"\"\"\n    Exports current account configuration in\n    shell-friendly form. Takes into account\n    explicit top-level flags like --organization.\n    \"\"\"\n    click.echo(\"# tonomi api\")\n    for (key, env) in REVERSE_MAPPING.items():\n        value = QUBELL.get(key, None)\n        if value:\n            click.echo(\"export %s='%s'\" % (env, value))\n    if any(map(lambda x: PROVIDER.get(x), REVERSE_PROVIDER_MAPPING.keys())):\n        click.echo(\"# cloud account\")\n        for (key, env) in REVERSE_PROVIDER_MAPPING.items():\n            value = PROVIDER.get(key, None)\n            if value:\n                click.echo(\"export %s='%s'\" % (env, value))"}
{"func_code_string": "def generate_session_token(refresh_token, verbose):\n    \"\"\"\n    Generates new session token from the given refresh token.\n    :param refresh_token: refresh token to generate from\n    :param verbose: whether expiration time should be added to output\n    \"\"\"\n\n    platform = _get_platform(authenticated=False)\n    session_token, expires_in = platform.generate_session_token(refresh_token)\n\n    if verbose:\n        click.echo(\"%s\\n\\n%s\" % (session_token, _color('YELLOW', \"Expires in %d seconds\" % expires_in)))\n    else:\n        click.echo(session_token)"}
{"func_code_string": "def runcommand(cosmology='WMAP5'):\n    \"\"\" Example interface commands \"\"\"\n\n    # Return the WMAP5 cosmology concentration predicted for\n    # z=0 range of masses\n    Mi = [1e8, 1e9, 1e10]\n    zi = 0\n    print(\"Concentrations for haloes of mass %s at z=%s\" % (Mi, zi))\n    output = commah.run(cosmology=cosmology, zi=zi, Mi=Mi)\n\n    print(output['c'].flatten())\n\n    # Return the WMAP5 cosmology concentration predicted for\n    # z=0 range of masses AND cosmological parameters\n    Mi = [1e8, 1e9, 1e10]\n    zi = 0\n    print(\"Concentrations for haloes of mass %s at z=%s\" % (Mi, zi))\n    output, cosmo = commah.run(cosmology=cosmology, zi=zi, Mi=Mi,\n                               retcosmo=True)\n\n    print(output['c'].flatten())\n    print(cosmo)\n\n    # Return the WMAP5 cosmology concentration predicted for MW\n    # mass (2e12 Msol) across redshift\n    Mi = 2e12\n    z = [0, 0.5, 1, 1.5, 2, 2.5]\n    output = commah.run(cosmology=cosmology, zi=0, Mi=Mi, z=z)\n    for zval in z:\n        print(\"M(z=0)=%s has c(z=%s)=%s\"\n              % (Mi, zval, output[output['z'] == zval]['c'].flatten()))\n\n    # Return the WMAP5 cosmology concentration predicted for MW\n    # mass (2e12 Msol) across redshift\n    Mi = 2e12\n    zi = [0, 0.5, 1, 1.5, 2, 2.5]\n    output = commah.run(cosmology=cosmology, zi=zi, Mi=Mi)\n    for zval in zi:\n        print(\"M(z=%s)=%s has concentration %s\"\n              % (zval, Mi, output[(output['zi'] == zval) &\n                                  (output['z'] == zval)]['c'].flatten()))\n\n    # Return the WMAP5 cosmology concentration and\n    # rarity of high-z cluster\n    Mi = 2e14\n    zi = 6\n    output = commah.run(cosmology=cosmology, zi=zi, Mi=Mi)\n    print(\"Concentrations for haloes of mass %s at z=%s\" % (Mi, zi))\n    print(output['c'].flatten())\n    print(\"Mass variance sigma of haloes of mass %s at z=%s\" % (Mi, zi))\n    print(output['sig'].flatten())\n    print(\"Fluctuation for haloes of mass %s at z=%s\" % (Mi, zi))\n    print(output['nu'].flatten())\n\n    # Return the WMAP5 cosmology accretion rate prediction\n    # for haloes at range of redshift and mass\n    Mi = [1e8, 1e9, 1e10]\n    zi = [0]\n    z = [0, 0.5, 1, 1.5, 2, 2.5]\n    output = commah.run(cosmology=cosmology, zi=zi, Mi=Mi, z=z)\n    for Mval in Mi:\n        print(\"dM/dt for halo of mass %s at z=%s across redshift %s is: \"\n              % (Mval, zi, z))\n        print(output[output['Mi'] == Mval]['dMdt'].flatten())\n\n    # Return the WMAP5 cosmology Halo Mass History for haloes with M(z=0) = 1e8\n    M = [1e8]\n    z = [0, 0.5, 1, 1.5, 2, 2.5]\n    print(\"Halo Mass History for z=0 mass of %s across z=%s\" % (M, z))\n    output = commah.run(cosmology=cosmology, zi=0, Mi=M, z=z)\n    print(output['Mz'].flatten())\n\n    # Return the WMAP5 cosmology formation redshifts for haloes at\n    # range of redshift and mass\n    M = [1e8, 1e9, 1e10]\n    z = [0]\n    print(\"Formation Redshifts for haloes of mass %s at z=%s\" % (M, z))\n    output = commah.run(cosmology=cosmology, zi=0, Mi=M, z=z)\n    for Mval in M:\n        print(output[output['Mi'] == Mval]['zf'].flatten())\n\n    return(\"Done\")"}
{"func_code_string": "def plotcommand(cosmology='WMAP5', plotname=None):\n    \"\"\" Example ways to interrogate the dataset and plot the commah output \"\"\"\n\n    # Plot the c-M relation as a functon of redshift\n    xarray = 10**(np.arange(1, 15, 0.2))\n    yval = 'c'\n\n    # Specify the redshift range\n    zarray = np.arange(0, 5, 0.5)\n\n    xtitle = r\"Halo Mass (M$_{sol}$)\"\n    ytitle = r\"Concentration\"\n    linelabel = \"z=\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(xtitle)\n    ax.set_ylabel(ytitle)\n    plt.ylim([2, 30])\n\n    colors = cm.rainbow(np.linspace(0, 1, len(zarray)))\n\n    for zind, zval in enumerate(zarray):\n        output = commah.run(cosmology=cosmology, zi=zval, Mi=xarray)\n\n        # Access the column yval from the data file\n        yarray = output[yval].flatten()\n\n        # Plot each line in turn with different colour\n        ax.plot(xarray, yarray, label=linelabel+str(zval), color=colors[zind])\n        # Overplot the D08 predictions in black\n        ax.plot(xarray, commah.commah.cduffy(zval, xarray), color=\"black\")\n\n    ax.set_xscale('log')\n    ax.set_yscale('log')\n\n    leg = ax.legend(loc=1)\n    # Make box totally transparent\n    leg.get_frame().set_alpha(0)\n    leg.get_frame().set_edgecolor('white')\n    for label in leg.get_texts():\n        label.set_fontsize('small')  # the font size\n    for label in leg.get_lines():\n        label.set_linewidth(4)   # the legend line width\n\n    if plotname:\n        fig.tight_layout(pad=0.2)\n        print(\"Plotting to '%s_CM_relation.png'\" % (plotname))\n        fig.savefig(plotname+\"_CM_relation.png\", dpi=fig.dpi*5)\n    else:\n        plt.show()\n\n    # Plot the c-z relation as a function of mass (so always Mz=M0)\n    xarray = 10**(np.arange(0, 1, 0.05)) - 1\n    yval = 'c'\n\n    # Specify the mass range\n    zarray = 10**np.arange(6, 14, 2)\n\n    xtitle = r\"Redshift\"\n    ytitle = r\"NFW Concentration\"\n    linelabel = r\"log$_{10}$ M$_{z}$(M$_{sol}$)=\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(xtitle)\n    ax.set_ylabel(ytitle)\n    colors = cm.rainbow(np.linspace(0, 1, len(zarray)))\n\n    for zind, zval in enumerate(zarray):\n        output = commah.run(cosmology=cosmology, zi=xarray, Mi=zval)\n\n        # Access the column yval from the data file\n        yarray = output[yval].flatten()\n\n        # Plot each line in turn with different colours\n        ax.plot(xarray, yarray,\n                label=linelabel+\"{0:.1f}\".format(np.log10(zval)),\n                color=colors[zind],)\n\n    leg = ax.legend(loc=1)\n    # Make box totally transparent\n    leg.get_frame().set_alpha(0)\n    leg.get_frame().set_edgecolor('white')\n    for label in leg.get_texts():\n        label.set_fontsize('small')  # the font size\n    for label in leg.get_lines():\n        label.set_linewidth(4)   # the legend line width\n\n    if plotname:\n        fig.tight_layout(pad=0.2)\n        print(\"Plotting to '%s_Cz_relation.png'\" % (plotname))\n        fig.savefig(plotname+\"_Cz_relation.png\", dpi=fig.dpi*5)\n    else:\n        plt.show()\n\n    # Plot the zf-z relation for different masses (so always Mz=M0)\n    xarray = 10**(np.arange(0, 1, 0.05)) - 1\n    yval = 'zf'\n\n    # Specify the mass range\n    zarray = 10**np.arange(6, 14, 2)\n\n    xtitle = r\"Redshift\"\n    ytitle = r\"Formation Redshift\"\n    linelabel = r\"log$_{10}$ M$_{z}$(M$_{sol}$)=\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(xtitle)\n    ax.set_ylabel(ytitle)\n    colors = cm.rainbow(np.linspace(0, 1, len(zarray)))\n\n    for zind, zval in enumerate(zarray):\n        output = commah.run(cosmology=cosmology, zi=xarray, Mi=zval)\n\n        yarray = output[yval].flatten()\n\n        # Plot each line in turn with different colour\n        ax.plot(xarray, yarray,\n                label=linelabel+\"{0:.1f}\".format(np.log10(zval)),\n                color=colors[zind],)\n\n    leg = ax.legend(loc=2)\n    # Make box totally transparent\n    leg.get_frame().set_alpha(0)\n    leg.get_frame().set_edgecolor('white')\n    for label in leg.get_texts():\n        label.set_fontsize('small')  # the font size\n    for label in leg.get_lines():\n        label.set_linewidth(4)   # the legend line width\n\n    if plotname:\n        fig.tight_layout(pad=0.2)\n        print(\"Plotting to '%s_zfz_relation.png'\" % (plotname))\n        fig.savefig(plotname+\"_zfz_relation.png\", dpi=fig.dpi*5)\n    else:\n        plt.show()\n\n    # Plot the dM/dt-z relation for different masses (so always Mz=M0)\n    xarray = 10**(np.arange(0, 1, 0.05)) - 1\n    yval = 'dMdt'\n\n    # Specify the mass range\n    zarray = 10**np.arange(10, 14, 0.5)\n\n    xtitle = r\"log$_{10}$ (1+z)\"\n    ytitle = r\"log$_{10}$ Accretion Rate M$_{sol}$ yr$^{-1}$\"\n    linelabel = r\"log$_{10}$ M$_z$(M$_{sol}$)=\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(xtitle)\n    ax.set_ylabel(ytitle)\n    colors = cm.rainbow(np.linspace(0, 1, len(zarray)))\n\n    cosmo = commah.getcosmo(cosmology)\n    for zind, zval in enumerate(zarray):\n        output = commah.run(cosmology=cosmology, zi=xarray, Mi=zval,\n                            com=False, mah=True)\n\n        yarray = output[yval].flatten()\n\n        # Plot each line in turn with different colour\n        ax.plot(np.log10(xarray+1.), np.log10(yarray),\n                label=linelabel+\"{0:.1f}\".format(np.log10(zval)),\n                color=colors[zind],)\n\n        # Plot the semi-analytic approximate formula from Correa et al 2015b\n        semianalytic_approx = 71.6 * (zval / 1e12) * (cosmo['h'] / 0.7) *\\\n            (-0.24 + 0.75 * (xarray + 1)) * np.sqrt(\n            cosmo['omega_M_0'] * (xarray + 1)**3 + cosmo['omega_lambda_0'])\n\n        ax.plot(np.log10(xarray + 1), np.log10(semianalytic_approx),\n                color='black')\n\n    leg = ax.legend(loc=2)\n    # Make box totally transparent\n    leg.get_frame().set_alpha(0)\n    leg.get_frame().set_edgecolor('white')\n    for label in leg.get_texts():\n        label.set_fontsize('small')  # the font size\n    for label in leg.get_lines():\n        label.set_linewidth(4)   # the legend line width\n\n    if plotname:\n        fig.tight_layout(pad=0.2)\n        print(\"Plotting to '%s_dMdtz_relation.png'\" % (plotname))\n        fig.savefig(plotname+\"_dMdtz_relation.png\", dpi=fig.dpi*5)\n    else:\n        plt.show()\n\n    # Plot the dMdt-M relation as a function of redshift\n    xarray = 10**(np.arange(10, 14, 0.5))\n    yval = 'dMdt'\n\n    # Specify the redshift range\n    zarray = np.arange(0, 5, 0.5)\n\n    xtitle = r\"Halo Mass M$_{sol}$\"\n    ytitle = r\"Accretion Rate M$_{sol}$ yr$^{-1}$\"\n    linelabel = \"z=\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(xtitle)\n    ax.set_ylabel(ytitle)\n    colors = cm.rainbow(np.linspace(0, 1, len(zarray)))\n\n    for zind, zval in enumerate(zarray):\n        output = commah.run(cosmology=cosmology, zi=zval, Mi=xarray,\n                            com=False, mah=True)\n\n        yarray = output[yval].flatten()\n\n        # Plot each line in turn with different colour\n        ax.plot(xarray, yarray, label=linelabel+str(zval),\n                color=colors[zind],)\n\n    ax.set_xscale('log')\n    ax.set_yscale('log')\n\n    leg = ax.legend(loc=2)\n    # Make box totally transparent\n    leg.get_frame().set_alpha(0)\n    leg.get_frame().set_edgecolor('white')\n    for label in leg.get_texts():\n        label.set_fontsize('small')  # the font size\n    for label in leg.get_lines():\n        label.set_linewidth(4)   # the legend line width\n\n    if plotname:\n        fig.tight_layout(pad=0.2)\n        print(\"Plotting to '%s_MAH_M_relation.png'\" % (plotname))\n        fig.savefig(plotname+\"_MAH_M_relation.png\", dpi=fig.dpi*5)\n    else:\n        plt.show()\n\n    # Plot the (dM/M)dt-M relation as a function of redshift\n    xarray = 10**(np.arange(10, 14, 0.5))\n    yval = 'dMdt'\n\n    # Specify the redshift range\n    zarray = np.arange(0, 5, 0.5)\n\n    xtitle = r\"Halo Mass M$_{sol}$\"\n    ytitle = r\"Specific Accretion Rate yr$^{-1}$\"\n    linelabel = \"z=\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(xtitle)\n    ax.set_ylabel(ytitle)\n    colors = cm.rainbow(np.linspace(0, 1, len(zarray)))\n\n    for zind, zval in enumerate(zarray):\n        output = commah.run(cosmology=cosmology, zi=zval, Mi=xarray,\n                            mah=True, com=False)\n\n        yarray = output[yval].flatten()\n\n        # Plot each line in turn with different colour\n        ax.plot(xarray, yarray/xarray, label=linelabel+str(zval),\n                color=colors[zind],)\n\n    ax.set_xscale('log')\n    ax.set_yscale('log')\n\n    leg = ax.legend(loc=1)\n    # Make box totally transparent\n    leg.get_frame().set_alpha(0)\n    leg.get_frame().set_edgecolor('white')\n    for label in leg.get_texts():\n        label.set_fontsize('small')  # the font size\n    for label in leg.get_lines():\n        label.set_linewidth(4)   # the legend line width\n\n    if plotname:\n        fig.tight_layout(pad=0.2)\n        print(\"Plotting to '%s_specificMAH_M_relation.png'\" % (plotname))\n        fig.savefig(plotname+\"_specificMAH_M_relation.png\", dpi=fig.dpi*5)\n    else:\n        plt.show()\n\n    # Plot the Mz-z relation as a function of mass\n    # (so mass is decreasing to zero as z-> inf)\n    xarray = 10**(np.arange(0, 1, 0.05)) - 1\n    yval = 'Mz'\n\n    # Specify the mass range\n    zarray = 10**np.arange(10, 14, 0.5)\n\n    xtitle = r\"Redshift\"\n    ytitle = r\"M(z) (M$_{sol}$)\"\n    linelabel = r\"log$_{10}$ M$_{0}$(M$_{sol}$)=\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(xtitle)\n    ax.set_ylabel(ytitle)\n    colors = cm.rainbow(np.linspace(0, 1, len(zarray)))\n\n    for zind, zval in enumerate(zarray):\n        output = commah.run(cosmology=cosmology, zi=0, Mi=zval, z=xarray)\n\n        yarray = output[yval].flatten()\n\n        # Plot each line in turn with different colour\n        ax.plot(xarray, yarray,\n                label=linelabel+\"{0:.1f}\".format(np.log10(zval)),\n                color=colors[zind],)\n\n    ax.set_yscale('log')\n\n    leg = ax.legend(loc=1)\n    # Make box totally transparent\n    leg.get_frame().set_alpha(0)\n    leg.get_frame().set_edgecolor('white')\n    for label in leg.get_texts():\n        label.set_fontsize('small')  # the font size\n    for label in leg.get_lines():\n        label.set_linewidth(4)   # the legend line width\n\n    if plotname:\n        fig.tight_layout(pad=0.2)\n        print(\"Plotting to '%s_Mzz_relation.png'\" % (plotname))\n        fig.savefig(plotname+\"_Mzz_relation.png\", dpi=fig.dpi*5)\n    else:\n        plt.show()\n\n    # Plot the Mz/M0-z relation as a function of mass\n    xarray = 10**(np.arange(0, 1, 0.02)) - 1\n    yval = 'Mz'\n\n    # Specify the mass range\n    zarray = 10**np.arange(10, 14, 0.5)\n\n    xtitle = r\"Redshift\"\n    ytitle = r\"log$_{10}$ M(z)/M$_{0}$\"\n    linelabel = r\"log$_{10}$ M$_{0}$(M$_{sol}$)=\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_xlabel(xtitle)\n    ax.set_ylabel(ytitle)\n    colors = cm.rainbow(np.linspace(0, 1, len(zarray)))\n\n    for zind, zval in enumerate(zarray):\n        output = commah.run(cosmology=cosmology, zi=0, Mi=zval, z=xarray)\n\n        yarray = output[yval].flatten()\n\n        # Plot each line in turn with different colour\n        ax.plot(xarray, np.log10(yarray/zval),\n                label=linelabel+\"{0:.1f}\".format(np.log10(zval)),\n                color=colors[zind],)\n\n    leg = ax.legend(loc=3)\n    # Make box totally transparent\n    leg.get_frame().set_alpha(0)\n    leg.get_frame().set_edgecolor('white')\n    for label in leg.get_texts():\n        label.set_fontsize('small')  # the font size\n    for label in leg.get_lines():\n        label.set_linewidth(4)   # the legend line width\n\n    if plotname:\n        fig.tight_layout(pad=0.2)\n        print(\"Plotting to '%s_MzM0z_relation.png'\" % (plotname))\n        fig.savefig(plotname+\"_MzM0z_relation.png\", dpi=fig.dpi*5)\n    else:\n        plt.show()\n\n    return(\"Done\")"}
{"func_code_string": "def enhance(self):\n        \"\"\" Function enhance\n        Enhance the object with new item or enhanced items\n        \"\"\"\n        self.update({'puppetclasses':\n                     SubDict(self.api, self.objName,\n                             self.payloadObj, self.key,\n                             SubItemPuppetClasses)})\n        self.update({'parameters':\n                     SubDict(self.api, self.objName,\n                             self.payloadObj, self.key,\n                             SubItemParameter)})\n        self.update({'smart_class_parameters':\n                    SubDict(self.api, self.objName,\n                            self.payloadObj, self.key,\n                            ItemSmartClassParameter)})"}
{"func_code_string": "def add_transformers(line):\n    '''Extract the transformers names from a line of code of the form\n       from __experimental__ import transformer1 [,...]\n       and adds them to the globally known dict\n    '''\n    assert FROM_EXPERIMENTAL.match(line)\n\n    line = FROM_EXPERIMENTAL.sub(' ', line)\n    # we now have: \" transformer1 [,...]\"\n    line = line.split(\"#\")[0]    # remove any end of line comments\n    # and insert each transformer as an item in a list\n    for trans in line.replace(' ', '').split(','):\n        import_transformer(trans)"}
{"func_code_string": "def import_transformer(name):\n    '''If needed, import a transformer, and adds it to the globally known dict\n       The code inside a module where a transformer is defined should be\n       standard Python code, which does not need any transformation.\n       So, we disable the import hook, and let the normal module import\n       do its job - which is faster and likely more reliable than our\n       custom method.\n    '''\n    if name in transformers:\n        return transformers[name]\n\n    # We are adding a transformer built from normal/standard Python code.\n    # As we are not performing transformations, we temporarily disable\n    # our import hook, both to avoid potential problems AND because we\n    # found that this resulted in much faster code.\n    hook = sys.meta_path[0]\n    sys.meta_path = sys.meta_path[1:]\n    try:\n        transformers[name] = __import__(name)\n        # Some transformers are not allowed in the console.\n        # If an attempt is made to activate one of them in the console,\n        # we replace it by a transformer that does nothing and print a\n        # message specific to that transformer as written in its module.\n        if CONSOLE_ACTIVE:\n            if hasattr(transformers[name], \"NO_CONSOLE\"):\n                print(transformers[name].NO_CONSOLE)\n                transformers[name] = NullTransformer()\n    except ImportError:\n        sys.stderr.write(\"Warning: Import Error in add_transformers: %s not found\\n\" % name)\n        transformers[name] = NullTransformer()\n    except Exception as e:\n        sys.stderr.write(\"Unexpected exception in transforms.import_transformer%s\\n \" %\n                         e.__class__.__name__)\n    finally:\n        sys.meta_path.insert(0, hook) # restore import hook\n\n    return transformers[name]"}
{"func_code_string": "def extract_transformers_from_source(source):\n    '''Scan a source for lines of the form\n       from __experimental__ import transformer1 [,...]\n       identifying transformers to be used. Such line is passed to the\n       add_transformer function, after which it is removed from the\n       code to be executed.\n    '''\n    lines = source.split('\\n')\n    linenumbers = []\n    for number, line in enumerate(lines):\n        if FROM_EXPERIMENTAL.match(line):\n            add_transformers(line)\n            linenumbers.insert(0, number)\n\n    # drop the \"fake\" import from the source code\n    for number in linenumbers:\n        del lines[number]\n    return '\\n'.join(lines)"}
{"func_code_string": "def remove_not_allowed_in_console():\n    '''This function should be called from the console, when it starts.\n\n    Some transformers are not allowed in the console and they could have\n    been loaded prior to the console being activated. We effectively remove them\n    and print an information message specific to that transformer\n    as written in the transformer module.\n\n    '''\n    not_allowed_in_console = []\n    if CONSOLE_ACTIVE:\n        for name in transformers:\n            tr_module = import_transformer(name)\n            if hasattr(tr_module, \"NO_CONSOLE\"):\n                not_allowed_in_console.append((name, tr_module))\n        for name, tr_module in not_allowed_in_console:\n            print(tr_module.NO_CONSOLE)\n            # Note: we do not remove them, so as to avoid seeing the\n            # information message displayed again if an attempt is\n            # made to re-import them from a console instruction.\n            transformers[name] = NullTransformer()"}
{"func_code_string": "def transform(source):\n    '''Used to convert the source code, making use of known transformers.\n\n       \"transformers\" are modules which must contain a function\n\n           transform_source(source)\n\n       which returns a tranformed source.\n       Some transformers (for example, those found in the standard library\n       module lib2to3) cannot cope with non-standard syntax; as a result, they\n       may fail during a first attempt. We keep track of all failing\n       transformers and keep retrying them until either they all succeeded\n       or a fixed set of them fails twice in a row.\n    '''\n    source = extract_transformers_from_source(source)\n\n    # Some transformer fail when multiple non-Python constructs\n    # are present. So, we loop multiple times keeping track of\n    # which transformations have been unsuccessfully performed.\n    not_done = transformers\n    while True:\n        failed = {}\n        for name in not_done:\n            tr_module = import_transformer(name)\n            try:\n                source = tr_module.transform_source(source)\n            except Exception as e:\n                failed[name] = tr_module\n                # from traceback import print_exc\n                # print(\"Unexpected exception in transforms.transform\",\n                #       e.__class__.__name__)\n                # print_exc()\n\n        if not failed:\n            break\n        # Insanity is doing the same Tting over and overaAgain and\n        # expecting different results ...\n        # If the exact same set of transformations are not performed\n        # twice in a row, there is no point in trying out a third time.\n        if failed == not_done:\n            print(\"Warning: the following transforms could not be done:\")\n            for key in failed:\n                print(key)\n            break\n        not_done = failed  # attempt another pass\n\n    return source"}
{"func_code_string": "def _match(self, request, response):\n        \"\"\"Match all requests/responses that satisfy the following conditions:\n\n        * An Admin App; i.e. the path is something like /admin/some_app/\n        * The ``include_flag`` is not in the response's content\n\n        \"\"\"\n        is_html = 'text/html' in response.get('Content-Type', '')\n        if is_html and hasattr(response, 'rendered_content'):\n            correct_path = PATH_MATCHER.match(request.path) is not None\n            not_included = self.include_flag not in response.rendered_content\n            return correct_path and not_included\n        return False"}
{"func_code_string": "def _chosen_css(self):\n        \"\"\"Read the minified CSS file including STATIC_URL in the references\n        to the sprite images.\"\"\"\n        css = render_to_string(self.css_template, {})\n        for sprite in self.chosen_sprites:  # rewrite path to sprites in the css\n            css = css.replace(sprite, settings.STATIC_URL + \"img/\" + sprite)\n        return css"}
{"func_code_string": "def _embed(self, request, response):\n        \"\"\"Embed Chosen.js directly in html of the response.\"\"\"\n        if self._match(request, response):\n            # Render the <link> and the <script> tags to include Chosen.\n            head = render_to_string(\n                \"chosenadmin/_head_css.html\",\n                {\"chosen_css\": self._chosen_css()}\n            )\n            body = render_to_string(\n                \"chosenadmin/_script.html\",\n                {\"chosen_js\": self._chosen_js()}\n            )\n\n            # Re-write the Response's content to include our new html\n            content = response.rendered_content\n            content = content.replace('</head>', head)\n            content = content.replace('</body>', body)\n            response.content = content\n        return response"}
{"func_code_string": "def clean_up(self):\n        \"\"\"\n        Close the I2C bus\n        \"\"\"\n        self.log.debug(\"Closing I2C bus for address: 0x%02X\" % self.address)\n        self.bus.close()"}
{"func_code_string": "def write_quick(self):\n        \"\"\"\n        Send only the read / write bit\n        \"\"\"\n        self.bus.write_quick(self.address)\n        self.log.debug(\"write_quick: Sent the read / write bit\")"}
{"func_code_string": "def write_byte(self, cmd, value):\n        \"\"\"\n        Writes an 8-bit byte to the specified command register\n        \"\"\"\n        self.bus.write_byte_data(self.address, cmd, value)\n        self.log.debug(\n            \"write_byte: Wrote 0x%02X to command register 0x%02X\" % (\n                value, cmd\n            )\n        )"}
{"func_code_string": "def write_word(self, cmd, value):\n        \"\"\"\n        Writes a 16-bit word to the specified command register\n        \"\"\"\n        self.bus.write_word_data(self.address, cmd, value)\n        self.log.debug(\n            \"write_word: Wrote 0x%04X to command register 0x%02X\" % (\n                value, cmd\n            )\n        )"}
{"func_code_string": "def write_raw_byte(self, value):\n        \"\"\"\n        Writes an 8-bit byte directly to the bus\n        \"\"\"\n        self.bus.write_byte(self.address, value)\n        self.log.debug(\"write_raw_byte: Wrote 0x%02X\" % value)"}
